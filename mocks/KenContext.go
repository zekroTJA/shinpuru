// Code generated by mockery v2.46.1. DO NOT EDIT.

package mocks

import (
	discordgo "github.com/bwmarrin/discordgo"
	ken "github.com/zekrotja/ken"

	mock "github.com/stretchr/testify/mock"
)

// KenContext is an autogenerated mock type for the Context type
type KenContext struct {
	mock.Mock
}

// Channel provides a mock function with given fields:
func (_m *KenContext) Channel() (*discordgo.Channel, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Channel")
	}

	var r0 *discordgo.Channel
	var r1 error
	if rf, ok := ret.Get(0).(func() (*discordgo.Channel, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *discordgo.Channel); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Channel)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Defer provides a mock function with given fields:
func (_m *KenContext) Defer() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Defer")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FollowUp provides a mock function with given fields: wait, data
func (_m *KenContext) FollowUp(wait bool, data *discordgo.WebhookParams) *ken.FollowUpMessageBuilder {
	ret := _m.Called(wait, data)

	if len(ret) == 0 {
		panic("no return value specified for FollowUp")
	}

	var r0 *ken.FollowUpMessageBuilder
	if rf, ok := ret.Get(0).(func(bool, *discordgo.WebhookParams) *ken.FollowUpMessageBuilder); ok {
		r0 = rf(wait, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ken.FollowUpMessageBuilder)
		}
	}

	return r0
}

// FollowUpEmbed provides a mock function with given fields: emb
func (_m *KenContext) FollowUpEmbed(emb *discordgo.MessageEmbed) *ken.FollowUpMessageBuilder {
	ret := _m.Called(emb)

	if len(ret) == 0 {
		panic("no return value specified for FollowUpEmbed")
	}

	var r0 *ken.FollowUpMessageBuilder
	if rf, ok := ret.Get(0).(func(*discordgo.MessageEmbed) *ken.FollowUpMessageBuilder); ok {
		r0 = rf(emb)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ken.FollowUpMessageBuilder)
		}
	}

	return r0
}

// FollowUpError provides a mock function with given fields: content, title
func (_m *KenContext) FollowUpError(content string, title string) *ken.FollowUpMessageBuilder {
	ret := _m.Called(content, title)

	if len(ret) == 0 {
		panic("no return value specified for FollowUpError")
	}

	var r0 *ken.FollowUpMessageBuilder
	if rf, ok := ret.Get(0).(func(string, string) *ken.FollowUpMessageBuilder); ok {
		r0 = rf(content, title)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ken.FollowUpMessageBuilder)
		}
	}

	return r0
}

// FollowUpMessage provides a mock function with given fields: message
func (_m *KenContext) FollowUpMessage(message string) *ken.FollowUpMessageBuilder {
	ret := _m.Called(message)

	if len(ret) == 0 {
		panic("no return value specified for FollowUpMessage")
	}

	var r0 *ken.FollowUpMessageBuilder
	if rf, ok := ret.Get(0).(func(string) *ken.FollowUpMessageBuilder); ok {
		r0 = rf(message)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ken.FollowUpMessageBuilder)
		}
	}

	return r0
}

// Get provides a mock function with given fields: key
func (_m *KenContext) Get(key string) interface{} {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(string) interface{}); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	return r0
}

// GetCommand provides a mock function with given fields:
func (_m *KenContext) GetCommand() ken.Command {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetCommand")
	}

	var r0 ken.Command
	if rf, ok := ret.Get(0).(func() ken.Command); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ken.Command)
		}
	}

	return r0
}

// GetEphemeral provides a mock function with given fields:
func (_m *KenContext) GetEphemeral() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetEphemeral")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// GetEvent provides a mock function with given fields:
func (_m *KenContext) GetEvent() *discordgo.InteractionCreate {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetEvent")
	}

	var r0 *discordgo.InteractionCreate
	if rf, ok := ret.Get(0).(func() *discordgo.InteractionCreate); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.InteractionCreate)
		}
	}

	return r0
}

// GetKen provides a mock function with given fields:
func (_m *KenContext) GetKen() *ken.Ken {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetKen")
	}

	var r0 *ken.Ken
	if rf, ok := ret.Get(0).(func() *ken.Ken); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ken.Ken)
		}
	}

	return r0
}

// GetSession provides a mock function with given fields:
func (_m *KenContext) GetSession() *discordgo.Session {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetSession")
	}

	var r0 *discordgo.Session
	if rf, ok := ret.Get(0).(func() *discordgo.Session); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Session)
		}
	}

	return r0
}

// Guild provides a mock function with given fields:
func (_m *KenContext) Guild() (*discordgo.Guild, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Guild")
	}

	var r0 *discordgo.Guild
	var r1 error
	if rf, ok := ret.Get(0).(func() (*discordgo.Guild, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *discordgo.Guild); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Guild)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HandleSubCommands provides a mock function with given fields: handler
func (_m *KenContext) HandleSubCommands(handler ...ken.CommandHandler) error {
	_va := make([]interface{}, len(handler))
	for _i := range handler {
		_va[_i] = handler[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HandleSubCommands")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(...ken.CommandHandler) error); ok {
		r0 = rf(handler...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MessageCommand provides a mock function with given fields:
func (_m *KenContext) MessageCommand() (ken.MessageCommand, bool) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for MessageCommand")
	}

	var r0 ken.MessageCommand
	var r1 bool
	if rf, ok := ret.Get(0).(func() (ken.MessageCommand, bool)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() ken.MessageCommand); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ken.MessageCommand)
		}
	}

	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *KenContext) Options() ken.CommandOptions {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 ken.CommandOptions
	if rf, ok := ret.Get(0).(func() ken.CommandOptions); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ken.CommandOptions)
		}
	}

	return r0
}

// ResetState provides a mock function with given fields:
func (_m *KenContext) ResetState() {
	_m.Called()
}

// Respond provides a mock function with given fields: r
func (_m *KenContext) Respond(r *discordgo.InteractionResponse) error {
	ret := _m.Called(r)

	if len(ret) == 0 {
		panic("no return value specified for Respond")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*discordgo.InteractionResponse) error); ok {
		r0 = rf(r)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RespondEmbed provides a mock function with given fields: emb
func (_m *KenContext) RespondEmbed(emb *discordgo.MessageEmbed) error {
	ret := _m.Called(emb)

	if len(ret) == 0 {
		panic("no return value specified for RespondEmbed")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*discordgo.MessageEmbed) error); ok {
		r0 = rf(emb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RespondError provides a mock function with given fields: content, title
func (_m *KenContext) RespondError(content string, title string) error {
	ret := _m.Called(content, title)

	if len(ret) == 0 {
		panic("no return value specified for RespondError")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(content, title)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RespondMessage provides a mock function with given fields: message
func (_m *KenContext) RespondMessage(message string) error {
	ret := _m.Called(message)

	if len(ret) == 0 {
		panic("no return value specified for RespondMessage")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(message)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetEphemeral provides a mock function with given fields: v
func (_m *KenContext) SetEphemeral(v bool) {
	_m.Called(v)
}

// SlashCommand provides a mock function with given fields:
func (_m *KenContext) SlashCommand() (ken.SlashCommand, bool) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for SlashCommand")
	}

	var r0 ken.SlashCommand
	var r1 bool
	if rf, ok := ret.Get(0).(func() (ken.SlashCommand, bool)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() ken.SlashCommand); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ken.SlashCommand)
		}
	}

	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// User provides a mock function with given fields:
func (_m *KenContext) User() *discordgo.User {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for User")
	}

	var r0 *discordgo.User
	if rf, ok := ret.Get(0).(func() *discordgo.User); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.User)
		}
	}

	return r0
}

// UserCommand provides a mock function with given fields:
func (_m *KenContext) UserCommand() (ken.UserCommand, bool) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for UserCommand")
	}

	var r0 ken.UserCommand
	var r1 bool
	if rf, ok := ret.Get(0).(func() (ken.UserCommand, bool)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() ken.UserCommand); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ken.UserCommand)
		}
	}

	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// NewKenContext creates a new instance of KenContext. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewKenContext(t interface {
	mock.TestingT
	Cleanup(func())
}) *KenContext {
	mock := &KenContext{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
