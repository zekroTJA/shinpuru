// Code generated by mockery v2.46.1. DO NOT EDIT.

package mocks

import (
	discordgo "github.com/bwmarrin/discordgo"

	image "image"

	io "io"

	mock "github.com/stretchr/testify/mock"

	time "time"
)

// ISession is an autogenerated mock type for the ISession type
type ISession struct {
	mock.Mock
}

// AddHandler provides a mock function with given fields: handler
func (_m *ISession) AddHandler(handler interface{}) func() {
	ret := _m.Called(handler)

	if len(ret) == 0 {
		panic("no return value specified for AddHandler")
	}

	var r0 func()
	if rf, ok := ret.Get(0).(func(interface{}) func()); ok {
		r0 = rf(handler)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(func())
		}
	}

	return r0
}

// AddHandlerOnce provides a mock function with given fields: handler
func (_m *ISession) AddHandlerOnce(handler interface{}) func() {
	ret := _m.Called(handler)

	if len(ret) == 0 {
		panic("no return value specified for AddHandlerOnce")
	}

	var r0 func()
	if rf, ok := ret.Get(0).(func(interface{}) func()); ok {
		r0 = rf(handler)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(func())
		}
	}

	return r0
}

// Application provides a mock function with given fields: appID
func (_m *ISession) Application(appID string) (*discordgo.Application, error) {
	ret := _m.Called(appID)

	if len(ret) == 0 {
		panic("no return value specified for Application")
	}

	var r0 *discordgo.Application
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*discordgo.Application, error)); ok {
		return rf(appID)
	}
	if rf, ok := ret.Get(0).(func(string) *discordgo.Application); ok {
		r0 = rf(appID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Application)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(appID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ApplicationAssets provides a mock function with given fields: appID
func (_m *ISession) ApplicationAssets(appID string) ([]*discordgo.Asset, error) {
	ret := _m.Called(appID)

	if len(ret) == 0 {
		panic("no return value specified for ApplicationAssets")
	}

	var r0 []*discordgo.Asset
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]*discordgo.Asset, error)); ok {
		return rf(appID)
	}
	if rf, ok := ret.Get(0).(func(string) []*discordgo.Asset); ok {
		r0 = rf(appID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.Asset)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(appID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ApplicationBotCreate provides a mock function with given fields: appID
func (_m *ISession) ApplicationBotCreate(appID string) (*discordgo.User, error) {
	ret := _m.Called(appID)

	if len(ret) == 0 {
		panic("no return value specified for ApplicationBotCreate")
	}

	var r0 *discordgo.User
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*discordgo.User, error)); ok {
		return rf(appID)
	}
	if rf, ok := ret.Get(0).(func(string) *discordgo.User); ok {
		r0 = rf(appID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.User)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(appID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ApplicationCommand provides a mock function with given fields: appID, guildID, cmdID, options
func (_m *ISession) ApplicationCommand(appID string, guildID string, cmdID string, options ...discordgo.RequestOption) (*discordgo.ApplicationCommand, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, appID, guildID, cmdID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ApplicationCommand")
	}

	var r0 *discordgo.ApplicationCommand
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, ...discordgo.RequestOption) (*discordgo.ApplicationCommand, error)); ok {
		return rf(appID, guildID, cmdID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, ...discordgo.RequestOption) *discordgo.ApplicationCommand); ok {
		r0 = rf(appID, guildID, cmdID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.ApplicationCommand)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(appID, guildID, cmdID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ApplicationCommandBulkOverwrite provides a mock function with given fields: appID, guildID, commands, options
func (_m *ISession) ApplicationCommandBulkOverwrite(appID string, guildID string, commands []*discordgo.ApplicationCommand, options ...discordgo.RequestOption) ([]*discordgo.ApplicationCommand, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, appID, guildID, commands)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ApplicationCommandBulkOverwrite")
	}

	var r0 []*discordgo.ApplicationCommand
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, []*discordgo.ApplicationCommand, ...discordgo.RequestOption) ([]*discordgo.ApplicationCommand, error)); ok {
		return rf(appID, guildID, commands, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, []*discordgo.ApplicationCommand, ...discordgo.RequestOption) []*discordgo.ApplicationCommand); ok {
		r0 = rf(appID, guildID, commands, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.ApplicationCommand)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, []*discordgo.ApplicationCommand, ...discordgo.RequestOption) error); ok {
		r1 = rf(appID, guildID, commands, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ApplicationCommandCreate provides a mock function with given fields: appID, guildID, cmd, options
func (_m *ISession) ApplicationCommandCreate(appID string, guildID string, cmd *discordgo.ApplicationCommand, options ...discordgo.RequestOption) (*discordgo.ApplicationCommand, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, appID, guildID, cmd)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ApplicationCommandCreate")
	}

	var r0 *discordgo.ApplicationCommand
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, *discordgo.ApplicationCommand, ...discordgo.RequestOption) (*discordgo.ApplicationCommand, error)); ok {
		return rf(appID, guildID, cmd, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, *discordgo.ApplicationCommand, ...discordgo.RequestOption) *discordgo.ApplicationCommand); ok {
		r0 = rf(appID, guildID, cmd, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.ApplicationCommand)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, *discordgo.ApplicationCommand, ...discordgo.RequestOption) error); ok {
		r1 = rf(appID, guildID, cmd, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ApplicationCommandDelete provides a mock function with given fields: appID, guildID, cmdID, options
func (_m *ISession) ApplicationCommandDelete(appID string, guildID string, cmdID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, appID, guildID, cmdID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ApplicationCommandDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(appID, guildID, cmdID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ApplicationCommandEdit provides a mock function with given fields: appID, guildID, cmdID, cmd, options
func (_m *ISession) ApplicationCommandEdit(appID string, guildID string, cmdID string, cmd *discordgo.ApplicationCommand, options ...discordgo.RequestOption) (*discordgo.ApplicationCommand, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, appID, guildID, cmdID, cmd)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ApplicationCommandEdit")
	}

	var r0 *discordgo.ApplicationCommand
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, *discordgo.ApplicationCommand, ...discordgo.RequestOption) (*discordgo.ApplicationCommand, error)); ok {
		return rf(appID, guildID, cmdID, cmd, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, *discordgo.ApplicationCommand, ...discordgo.RequestOption) *discordgo.ApplicationCommand); ok {
		r0 = rf(appID, guildID, cmdID, cmd, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.ApplicationCommand)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, *discordgo.ApplicationCommand, ...discordgo.RequestOption) error); ok {
		r1 = rf(appID, guildID, cmdID, cmd, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ApplicationCommandPermissions provides a mock function with given fields: appID, guildID, cmdID, options
func (_m *ISession) ApplicationCommandPermissions(appID string, guildID string, cmdID string, options ...discordgo.RequestOption) (*discordgo.GuildApplicationCommandPermissions, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, appID, guildID, cmdID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ApplicationCommandPermissions")
	}

	var r0 *discordgo.GuildApplicationCommandPermissions
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, ...discordgo.RequestOption) (*discordgo.GuildApplicationCommandPermissions, error)); ok {
		return rf(appID, guildID, cmdID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, ...discordgo.RequestOption) *discordgo.GuildApplicationCommandPermissions); ok {
		r0 = rf(appID, guildID, cmdID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.GuildApplicationCommandPermissions)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(appID, guildID, cmdID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ApplicationCommandPermissionsBatchEdit provides a mock function with given fields: appID, guildID, permissions, options
func (_m *ISession) ApplicationCommandPermissionsBatchEdit(appID string, guildID string, permissions []*discordgo.GuildApplicationCommandPermissions, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, appID, guildID, permissions)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ApplicationCommandPermissionsBatchEdit")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, []*discordgo.GuildApplicationCommandPermissions, ...discordgo.RequestOption) error); ok {
		r0 = rf(appID, guildID, permissions, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ApplicationCommandPermissionsEdit provides a mock function with given fields: appID, guildID, cmdID, permissions, options
func (_m *ISession) ApplicationCommandPermissionsEdit(appID string, guildID string, cmdID string, permissions *discordgo.ApplicationCommandPermissionsList, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, appID, guildID, cmdID, permissions)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ApplicationCommandPermissionsEdit")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, *discordgo.ApplicationCommandPermissionsList, ...discordgo.RequestOption) error); ok {
		r0 = rf(appID, guildID, cmdID, permissions, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ApplicationCommands provides a mock function with given fields: appID, guildID, options
func (_m *ISession) ApplicationCommands(appID string, guildID string, options ...discordgo.RequestOption) ([]*discordgo.ApplicationCommand, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, appID, guildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ApplicationCommands")
	}

	var r0 []*discordgo.ApplicationCommand
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) ([]*discordgo.ApplicationCommand, error)); ok {
		return rf(appID, guildID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) []*discordgo.ApplicationCommand); ok {
		r0 = rf(appID, guildID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.ApplicationCommand)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(appID, guildID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ApplicationCreate provides a mock function with given fields: ap
func (_m *ISession) ApplicationCreate(ap *discordgo.Application) (*discordgo.Application, error) {
	ret := _m.Called(ap)

	if len(ret) == 0 {
		panic("no return value specified for ApplicationCreate")
	}

	var r0 *discordgo.Application
	var r1 error
	if rf, ok := ret.Get(0).(func(*discordgo.Application) (*discordgo.Application, error)); ok {
		return rf(ap)
	}
	if rf, ok := ret.Get(0).(func(*discordgo.Application) *discordgo.Application); ok {
		r0 = rf(ap)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Application)
		}
	}

	if rf, ok := ret.Get(1).(func(*discordgo.Application) error); ok {
		r1 = rf(ap)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ApplicationDelete provides a mock function with given fields: appID
func (_m *ISession) ApplicationDelete(appID string) error {
	ret := _m.Called(appID)

	if len(ret) == 0 {
		panic("no return value specified for ApplicationDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(appID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ApplicationRoleConnectionMetadata provides a mock function with given fields: appID
func (_m *ISession) ApplicationRoleConnectionMetadata(appID string) ([]*discordgo.ApplicationRoleConnectionMetadata, error) {
	ret := _m.Called(appID)

	if len(ret) == 0 {
		panic("no return value specified for ApplicationRoleConnectionMetadata")
	}

	var r0 []*discordgo.ApplicationRoleConnectionMetadata
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]*discordgo.ApplicationRoleConnectionMetadata, error)); ok {
		return rf(appID)
	}
	if rf, ok := ret.Get(0).(func(string) []*discordgo.ApplicationRoleConnectionMetadata); ok {
		r0 = rf(appID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.ApplicationRoleConnectionMetadata)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(appID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ApplicationRoleConnectionMetadataUpdate provides a mock function with given fields: appID, metadata
func (_m *ISession) ApplicationRoleConnectionMetadataUpdate(appID string, metadata []*discordgo.ApplicationRoleConnectionMetadata) ([]*discordgo.ApplicationRoleConnectionMetadata, error) {
	ret := _m.Called(appID, metadata)

	if len(ret) == 0 {
		panic("no return value specified for ApplicationRoleConnectionMetadataUpdate")
	}

	var r0 []*discordgo.ApplicationRoleConnectionMetadata
	var r1 error
	if rf, ok := ret.Get(0).(func(string, []*discordgo.ApplicationRoleConnectionMetadata) ([]*discordgo.ApplicationRoleConnectionMetadata, error)); ok {
		return rf(appID, metadata)
	}
	if rf, ok := ret.Get(0).(func(string, []*discordgo.ApplicationRoleConnectionMetadata) []*discordgo.ApplicationRoleConnectionMetadata); ok {
		r0 = rf(appID, metadata)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.ApplicationRoleConnectionMetadata)
		}
	}

	if rf, ok := ret.Get(1).(func(string, []*discordgo.ApplicationRoleConnectionMetadata) error); ok {
		r1 = rf(appID, metadata)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ApplicationUpdate provides a mock function with given fields: appID, ap
func (_m *ISession) ApplicationUpdate(appID string, ap *discordgo.Application) (*discordgo.Application, error) {
	ret := _m.Called(appID, ap)

	if len(ret) == 0 {
		panic("no return value specified for ApplicationUpdate")
	}

	var r0 *discordgo.Application
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *discordgo.Application) (*discordgo.Application, error)); ok {
		return rf(appID, ap)
	}
	if rf, ok := ret.Get(0).(func(string, *discordgo.Application) *discordgo.Application); ok {
		r0 = rf(appID, ap)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Application)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *discordgo.Application) error); ok {
		r1 = rf(appID, ap)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Applications provides a mock function with given fields:
func (_m *ISession) Applications() ([]*discordgo.Application, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Applications")
	}

	var r0 []*discordgo.Application
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]*discordgo.Application, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []*discordgo.Application); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.Application)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AutoModerationRule provides a mock function with given fields: guildID, ruleID, options
func (_m *ISession) AutoModerationRule(guildID string, ruleID string, options ...discordgo.RequestOption) (*discordgo.AutoModerationRule, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, ruleID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AutoModerationRule")
	}

	var r0 *discordgo.AutoModerationRule
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) (*discordgo.AutoModerationRule, error)); ok {
		return rf(guildID, ruleID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) *discordgo.AutoModerationRule); ok {
		r0 = rf(guildID, ruleID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.AutoModerationRule)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, ruleID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AutoModerationRuleCreate provides a mock function with given fields: guildID, rule, options
func (_m *ISession) AutoModerationRuleCreate(guildID string, rule *discordgo.AutoModerationRule, options ...discordgo.RequestOption) (*discordgo.AutoModerationRule, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, rule)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AutoModerationRuleCreate")
	}

	var r0 *discordgo.AutoModerationRule
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *discordgo.AutoModerationRule, ...discordgo.RequestOption) (*discordgo.AutoModerationRule, error)); ok {
		return rf(guildID, rule, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *discordgo.AutoModerationRule, ...discordgo.RequestOption) *discordgo.AutoModerationRule); ok {
		r0 = rf(guildID, rule, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.AutoModerationRule)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *discordgo.AutoModerationRule, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, rule, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AutoModerationRuleDelete provides a mock function with given fields: guildID, ruleID, options
func (_m *ISession) AutoModerationRuleDelete(guildID string, ruleID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, ruleID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AutoModerationRuleDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, ruleID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AutoModerationRuleEdit provides a mock function with given fields: guildID, ruleID, rule, options
func (_m *ISession) AutoModerationRuleEdit(guildID string, ruleID string, rule *discordgo.AutoModerationRule, options ...discordgo.RequestOption) (*discordgo.AutoModerationRule, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, ruleID, rule)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AutoModerationRuleEdit")
	}

	var r0 *discordgo.AutoModerationRule
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, *discordgo.AutoModerationRule, ...discordgo.RequestOption) (*discordgo.AutoModerationRule, error)); ok {
		return rf(guildID, ruleID, rule, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, *discordgo.AutoModerationRule, ...discordgo.RequestOption) *discordgo.AutoModerationRule); ok {
		r0 = rf(guildID, ruleID, rule, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.AutoModerationRule)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, *discordgo.AutoModerationRule, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, ruleID, rule, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AutoModerationRules provides a mock function with given fields: guildID, options
func (_m *ISession) AutoModerationRules(guildID string, options ...discordgo.RequestOption) ([]*discordgo.AutoModerationRule, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AutoModerationRules")
	}

	var r0 []*discordgo.AutoModerationRule
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) ([]*discordgo.AutoModerationRule, error)); ok {
		return rf(guildID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) []*discordgo.AutoModerationRule); ok {
		r0 = rf(guildID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.AutoModerationRule)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Channel provides a mock function with given fields: channelID, options
func (_m *ISession) Channel(channelID string, options ...discordgo.RequestOption) (*discordgo.Channel, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Channel")
	}

	var r0 *discordgo.Channel
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) (*discordgo.Channel, error)); ok {
		return rf(channelID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) *discordgo.Channel); ok {
		r0 = rf(channelID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Channel)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelDelete provides a mock function with given fields: channelID, options
func (_m *ISession) ChannelDelete(channelID string, options ...discordgo.RequestOption) (*discordgo.Channel, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelDelete")
	}

	var r0 *discordgo.Channel
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) (*discordgo.Channel, error)); ok {
		return rf(channelID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) *discordgo.Channel); ok {
		r0 = rf(channelID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Channel)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelEdit provides a mock function with given fields: channelID, data, options
func (_m *ISession) ChannelEdit(channelID string, data *discordgo.ChannelEdit, options ...discordgo.RequestOption) (*discordgo.Channel, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelEdit")
	}

	var r0 *discordgo.Channel
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *discordgo.ChannelEdit, ...discordgo.RequestOption) (*discordgo.Channel, error)); ok {
		return rf(channelID, data, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *discordgo.ChannelEdit, ...discordgo.RequestOption) *discordgo.Channel); ok {
		r0 = rf(channelID, data, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Channel)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *discordgo.ChannelEdit, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, data, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelEditComplex provides a mock function with given fields: channelID, data, options
func (_m *ISession) ChannelEditComplex(channelID string, data *discordgo.ChannelEdit, options ...discordgo.RequestOption) (*discordgo.Channel, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelEditComplex")
	}

	var r0 *discordgo.Channel
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *discordgo.ChannelEdit, ...discordgo.RequestOption) (*discordgo.Channel, error)); ok {
		return rf(channelID, data, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *discordgo.ChannelEdit, ...discordgo.RequestOption) *discordgo.Channel); ok {
		r0 = rf(channelID, data, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Channel)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *discordgo.ChannelEdit, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, data, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelFileSend provides a mock function with given fields: channelID, name, r, options
func (_m *ISession) ChannelFileSend(channelID string, name string, r io.Reader, options ...discordgo.RequestOption) (*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, name, r)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelFileSend")
	}

	var r0 *discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, io.Reader, ...discordgo.RequestOption) (*discordgo.Message, error)); ok {
		return rf(channelID, name, r, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, io.Reader, ...discordgo.RequestOption) *discordgo.Message); ok {
		r0 = rf(channelID, name, r, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, io.Reader, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, name, r, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelFileSendWithMessage provides a mock function with given fields: channelID, content, name, r, options
func (_m *ISession) ChannelFileSendWithMessage(channelID string, content string, name string, r io.Reader, options ...discordgo.RequestOption) (*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, content, name, r)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelFileSendWithMessage")
	}

	var r0 *discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, io.Reader, ...discordgo.RequestOption) (*discordgo.Message, error)); ok {
		return rf(channelID, content, name, r, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, io.Reader, ...discordgo.RequestOption) *discordgo.Message); ok {
		r0 = rf(channelID, content, name, r, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, io.Reader, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, content, name, r, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelInviteCreate provides a mock function with given fields: channelID, i, options
func (_m *ISession) ChannelInviteCreate(channelID string, i discordgo.Invite, options ...discordgo.RequestOption) (*discordgo.Invite, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, i)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelInviteCreate")
	}

	var r0 *discordgo.Invite
	var r1 error
	if rf, ok := ret.Get(0).(func(string, discordgo.Invite, ...discordgo.RequestOption) (*discordgo.Invite, error)); ok {
		return rf(channelID, i, options...)
	}
	if rf, ok := ret.Get(0).(func(string, discordgo.Invite, ...discordgo.RequestOption) *discordgo.Invite); ok {
		r0 = rf(channelID, i, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Invite)
		}
	}

	if rf, ok := ret.Get(1).(func(string, discordgo.Invite, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, i, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelInvites provides a mock function with given fields: channelID, options
func (_m *ISession) ChannelInvites(channelID string, options ...discordgo.RequestOption) ([]*discordgo.Invite, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelInvites")
	}

	var r0 []*discordgo.Invite
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) ([]*discordgo.Invite, error)); ok {
		return rf(channelID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) []*discordgo.Invite); ok {
		r0 = rf(channelID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.Invite)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelMessage provides a mock function with given fields: channelID, messageID, options
func (_m *ISession) ChannelMessage(channelID string, messageID string, options ...discordgo.RequestOption) (*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, messageID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessage")
	}

	var r0 *discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) (*discordgo.Message, error)); ok {
		return rf(channelID, messageID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) *discordgo.Message); ok {
		r0 = rf(channelID, messageID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, messageID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelMessageCrosspost provides a mock function with given fields: channelID, messageID, options
func (_m *ISession) ChannelMessageCrosspost(channelID string, messageID string, options ...discordgo.RequestOption) (*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, messageID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessageCrosspost")
	}

	var r0 *discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) (*discordgo.Message, error)); ok {
		return rf(channelID, messageID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) *discordgo.Message); ok {
		r0 = rf(channelID, messageID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, messageID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelMessageDelete provides a mock function with given fields: channelID, messageID, options
func (_m *ISession) ChannelMessageDelete(channelID string, messageID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, messageID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessageDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(channelID, messageID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ChannelMessageEdit provides a mock function with given fields: channelID, messageID, content, options
func (_m *ISession) ChannelMessageEdit(channelID string, messageID string, content string, options ...discordgo.RequestOption) (*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, messageID, content)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessageEdit")
	}

	var r0 *discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, ...discordgo.RequestOption) (*discordgo.Message, error)); ok {
		return rf(channelID, messageID, content, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, ...discordgo.RequestOption) *discordgo.Message); ok {
		r0 = rf(channelID, messageID, content, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, messageID, content, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelMessageEditComplex provides a mock function with given fields: m, options
func (_m *ISession) ChannelMessageEditComplex(m *discordgo.MessageEdit, options ...discordgo.RequestOption) (*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, m)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessageEditComplex")
	}

	var r0 *discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(*discordgo.MessageEdit, ...discordgo.RequestOption) (*discordgo.Message, error)); ok {
		return rf(m, options...)
	}
	if rf, ok := ret.Get(0).(func(*discordgo.MessageEdit, ...discordgo.RequestOption) *discordgo.Message); ok {
		r0 = rf(m, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(*discordgo.MessageEdit, ...discordgo.RequestOption) error); ok {
		r1 = rf(m, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelMessageEditEmbed provides a mock function with given fields: channelID, messageID, embed, options
func (_m *ISession) ChannelMessageEditEmbed(channelID string, messageID string, embed *discordgo.MessageEmbed, options ...discordgo.RequestOption) (*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, messageID, embed)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessageEditEmbed")
	}

	var r0 *discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, *discordgo.MessageEmbed, ...discordgo.RequestOption) (*discordgo.Message, error)); ok {
		return rf(channelID, messageID, embed, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, *discordgo.MessageEmbed, ...discordgo.RequestOption) *discordgo.Message); ok {
		r0 = rf(channelID, messageID, embed, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, *discordgo.MessageEmbed, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, messageID, embed, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelMessageEditEmbeds provides a mock function with given fields: channelID, messageID, embeds, options
func (_m *ISession) ChannelMessageEditEmbeds(channelID string, messageID string, embeds []*discordgo.MessageEmbed, options ...discordgo.RequestOption) (*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, messageID, embeds)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessageEditEmbeds")
	}

	var r0 *discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, []*discordgo.MessageEmbed, ...discordgo.RequestOption) (*discordgo.Message, error)); ok {
		return rf(channelID, messageID, embeds, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, []*discordgo.MessageEmbed, ...discordgo.RequestOption) *discordgo.Message); ok {
		r0 = rf(channelID, messageID, embeds, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, []*discordgo.MessageEmbed, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, messageID, embeds, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelMessagePin provides a mock function with given fields: channelID, messageID, options
func (_m *ISession) ChannelMessagePin(channelID string, messageID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, messageID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessagePin")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(channelID, messageID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ChannelMessageSend provides a mock function with given fields: channelID, content, options
func (_m *ISession) ChannelMessageSend(channelID string, content string, options ...discordgo.RequestOption) (*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, content)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessageSend")
	}

	var r0 *discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) (*discordgo.Message, error)); ok {
		return rf(channelID, content, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) *discordgo.Message); ok {
		r0 = rf(channelID, content, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, content, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelMessageSendComplex provides a mock function with given fields: channelID, data, options
func (_m *ISession) ChannelMessageSendComplex(channelID string, data *discordgo.MessageSend, options ...discordgo.RequestOption) (*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessageSendComplex")
	}

	var r0 *discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *discordgo.MessageSend, ...discordgo.RequestOption) (*discordgo.Message, error)); ok {
		return rf(channelID, data, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *discordgo.MessageSend, ...discordgo.RequestOption) *discordgo.Message); ok {
		r0 = rf(channelID, data, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *discordgo.MessageSend, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, data, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelMessageSendEmbed provides a mock function with given fields: channelID, embed, options
func (_m *ISession) ChannelMessageSendEmbed(channelID string, embed *discordgo.MessageEmbed, options ...discordgo.RequestOption) (*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, embed)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessageSendEmbed")
	}

	var r0 *discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *discordgo.MessageEmbed, ...discordgo.RequestOption) (*discordgo.Message, error)); ok {
		return rf(channelID, embed, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *discordgo.MessageEmbed, ...discordgo.RequestOption) *discordgo.Message); ok {
		r0 = rf(channelID, embed, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *discordgo.MessageEmbed, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, embed, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelMessageSendEmbedReply provides a mock function with given fields: channelID, embed, reference, options
func (_m *ISession) ChannelMessageSendEmbedReply(channelID string, embed *discordgo.MessageEmbed, reference *discordgo.MessageReference, options ...discordgo.RequestOption) (*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, embed, reference)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessageSendEmbedReply")
	}

	var r0 *discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *discordgo.MessageEmbed, *discordgo.MessageReference, ...discordgo.RequestOption) (*discordgo.Message, error)); ok {
		return rf(channelID, embed, reference, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *discordgo.MessageEmbed, *discordgo.MessageReference, ...discordgo.RequestOption) *discordgo.Message); ok {
		r0 = rf(channelID, embed, reference, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *discordgo.MessageEmbed, *discordgo.MessageReference, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, embed, reference, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelMessageSendEmbeds provides a mock function with given fields: channelID, embeds, options
func (_m *ISession) ChannelMessageSendEmbeds(channelID string, embeds []*discordgo.MessageEmbed, options ...discordgo.RequestOption) (*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, embeds)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessageSendEmbeds")
	}

	var r0 *discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(string, []*discordgo.MessageEmbed, ...discordgo.RequestOption) (*discordgo.Message, error)); ok {
		return rf(channelID, embeds, options...)
	}
	if rf, ok := ret.Get(0).(func(string, []*discordgo.MessageEmbed, ...discordgo.RequestOption) *discordgo.Message); ok {
		r0 = rf(channelID, embeds, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(string, []*discordgo.MessageEmbed, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, embeds, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelMessageSendEmbedsReply provides a mock function with given fields: channelID, embeds, reference, options
func (_m *ISession) ChannelMessageSendEmbedsReply(channelID string, embeds []*discordgo.MessageEmbed, reference *discordgo.MessageReference, options ...discordgo.RequestOption) (*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, embeds, reference)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessageSendEmbedsReply")
	}

	var r0 *discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(string, []*discordgo.MessageEmbed, *discordgo.MessageReference, ...discordgo.RequestOption) (*discordgo.Message, error)); ok {
		return rf(channelID, embeds, reference, options...)
	}
	if rf, ok := ret.Get(0).(func(string, []*discordgo.MessageEmbed, *discordgo.MessageReference, ...discordgo.RequestOption) *discordgo.Message); ok {
		r0 = rf(channelID, embeds, reference, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(string, []*discordgo.MessageEmbed, *discordgo.MessageReference, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, embeds, reference, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelMessageSendReply provides a mock function with given fields: channelID, content, reference, options
func (_m *ISession) ChannelMessageSendReply(channelID string, content string, reference *discordgo.MessageReference, options ...discordgo.RequestOption) (*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, content, reference)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessageSendReply")
	}

	var r0 *discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, *discordgo.MessageReference, ...discordgo.RequestOption) (*discordgo.Message, error)); ok {
		return rf(channelID, content, reference, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, *discordgo.MessageReference, ...discordgo.RequestOption) *discordgo.Message); ok {
		r0 = rf(channelID, content, reference, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, *discordgo.MessageReference, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, content, reference, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelMessageSendTTS provides a mock function with given fields: channelID, content, options
func (_m *ISession) ChannelMessageSendTTS(channelID string, content string, options ...discordgo.RequestOption) (*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, content)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessageSendTTS")
	}

	var r0 *discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) (*discordgo.Message, error)); ok {
		return rf(channelID, content, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) *discordgo.Message); ok {
		r0 = rf(channelID, content, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, content, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelMessageUnpin provides a mock function with given fields: channelID, messageID, options
func (_m *ISession) ChannelMessageUnpin(channelID string, messageID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, messageID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessageUnpin")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(channelID, messageID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ChannelMessages provides a mock function with given fields: channelID, limit, beforeID, afterID, aroundID, options
func (_m *ISession) ChannelMessages(channelID string, limit int, beforeID string, afterID string, aroundID string, options ...discordgo.RequestOption) ([]*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, limit, beforeID, afterID, aroundID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessages")
	}

	var r0 []*discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int, string, string, string, ...discordgo.RequestOption) ([]*discordgo.Message, error)); ok {
		return rf(channelID, limit, beforeID, afterID, aroundID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, int, string, string, string, ...discordgo.RequestOption) []*discordgo.Message); ok {
		r0 = rf(channelID, limit, beforeID, afterID, aroundID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(string, int, string, string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, limit, beforeID, afterID, aroundID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelMessagesBulkDelete provides a mock function with given fields: channelID, messages, options
func (_m *ISession) ChannelMessagesBulkDelete(channelID string, messages []string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, messages)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessagesBulkDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, []string, ...discordgo.RequestOption) error); ok {
		r0 = rf(channelID, messages, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ChannelMessagesPinned provides a mock function with given fields: channelID, options
func (_m *ISession) ChannelMessagesPinned(channelID string, options ...discordgo.RequestOption) ([]*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelMessagesPinned")
	}

	var r0 []*discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) ([]*discordgo.Message, error)); ok {
		return rf(channelID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) []*discordgo.Message); ok {
		r0 = rf(channelID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelNewsFollow provides a mock function with given fields: channelID, targetID, options
func (_m *ISession) ChannelNewsFollow(channelID string, targetID string, options ...discordgo.RequestOption) (*discordgo.ChannelFollow, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, targetID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelNewsFollow")
	}

	var r0 *discordgo.ChannelFollow
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) (*discordgo.ChannelFollow, error)); ok {
		return rf(channelID, targetID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) *discordgo.ChannelFollow); ok {
		r0 = rf(channelID, targetID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.ChannelFollow)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, targetID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelPermissionDelete provides a mock function with given fields: channelID, targetID, options
func (_m *ISession) ChannelPermissionDelete(channelID string, targetID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, targetID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelPermissionDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(channelID, targetID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ChannelPermissionSet provides a mock function with given fields: channelID, targetID, targetType, allow, deny, options
func (_m *ISession) ChannelPermissionSet(channelID string, targetID string, targetType discordgo.PermissionOverwriteType, allow int64, deny int64, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, targetID, targetType, allow, deny)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelPermissionSet")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, discordgo.PermissionOverwriteType, int64, int64, ...discordgo.RequestOption) error); ok {
		r0 = rf(channelID, targetID, targetType, allow, deny, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ChannelTyping provides a mock function with given fields: channelID, options
func (_m *ISession) ChannelTyping(channelID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelTyping")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) error); ok {
		r0 = rf(channelID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ChannelVoiceJoin provides a mock function with given fields: gID, cID, mute, deaf
func (_m *ISession) ChannelVoiceJoin(gID string, cID string, mute bool, deaf bool) (*discordgo.VoiceConnection, error) {
	ret := _m.Called(gID, cID, mute, deaf)

	if len(ret) == 0 {
		panic("no return value specified for ChannelVoiceJoin")
	}

	var r0 *discordgo.VoiceConnection
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, bool, bool) (*discordgo.VoiceConnection, error)); ok {
		return rf(gID, cID, mute, deaf)
	}
	if rf, ok := ret.Get(0).(func(string, string, bool, bool) *discordgo.VoiceConnection); ok {
		r0 = rf(gID, cID, mute, deaf)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.VoiceConnection)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, bool, bool) error); ok {
		r1 = rf(gID, cID, mute, deaf)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelVoiceJoinManual provides a mock function with given fields: gID, cID, mute, deaf
func (_m *ISession) ChannelVoiceJoinManual(gID string, cID string, mute bool, deaf bool) error {
	ret := _m.Called(gID, cID, mute, deaf)

	if len(ret) == 0 {
		panic("no return value specified for ChannelVoiceJoinManual")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, bool, bool) error); ok {
		r0 = rf(gID, cID, mute, deaf)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ChannelWebhooks provides a mock function with given fields: channelID, options
func (_m *ISession) ChannelWebhooks(channelID string, options ...discordgo.RequestOption) ([]*discordgo.Webhook, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChannelWebhooks")
	}

	var r0 []*discordgo.Webhook
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) ([]*discordgo.Webhook, error)); ok {
		return rf(channelID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) []*discordgo.Webhook); ok {
		r0 = rf(channelID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.Webhook)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Close provides a mock function with given fields:
func (_m *ISession) Close() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CloseWithCode provides a mock function with given fields: closeCode
func (_m *ISession) CloseWithCode(closeCode int) error {
	ret := _m.Called(closeCode)

	if len(ret) == 0 {
		panic("no return value specified for CloseWithCode")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int) error); ok {
		r0 = rf(closeCode)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FollowupMessageCreate provides a mock function with given fields: interaction, wait, data, options
func (_m *ISession) FollowupMessageCreate(interaction *discordgo.Interaction, wait bool, data *discordgo.WebhookParams, options ...discordgo.RequestOption) (*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, interaction, wait, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FollowupMessageCreate")
	}

	var r0 *discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(*discordgo.Interaction, bool, *discordgo.WebhookParams, ...discordgo.RequestOption) (*discordgo.Message, error)); ok {
		return rf(interaction, wait, data, options...)
	}
	if rf, ok := ret.Get(0).(func(*discordgo.Interaction, bool, *discordgo.WebhookParams, ...discordgo.RequestOption) *discordgo.Message); ok {
		r0 = rf(interaction, wait, data, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(*discordgo.Interaction, bool, *discordgo.WebhookParams, ...discordgo.RequestOption) error); ok {
		r1 = rf(interaction, wait, data, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FollowupMessageDelete provides a mock function with given fields: interaction, messageID, options
func (_m *ISession) FollowupMessageDelete(interaction *discordgo.Interaction, messageID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, interaction, messageID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FollowupMessageDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*discordgo.Interaction, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(interaction, messageID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FollowupMessageEdit provides a mock function with given fields: interaction, messageID, data, options
func (_m *ISession) FollowupMessageEdit(interaction *discordgo.Interaction, messageID string, data *discordgo.WebhookEdit, options ...discordgo.RequestOption) (*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, interaction, messageID, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FollowupMessageEdit")
	}

	var r0 *discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(*discordgo.Interaction, string, *discordgo.WebhookEdit, ...discordgo.RequestOption) (*discordgo.Message, error)); ok {
		return rf(interaction, messageID, data, options...)
	}
	if rf, ok := ret.Get(0).(func(*discordgo.Interaction, string, *discordgo.WebhookEdit, ...discordgo.RequestOption) *discordgo.Message); ok {
		r0 = rf(interaction, messageID, data, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(*discordgo.Interaction, string, *discordgo.WebhookEdit, ...discordgo.RequestOption) error); ok {
		r1 = rf(interaction, messageID, data, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ForumThreadStart provides a mock function with given fields: channelID, name, archiveDuration, content, options
func (_m *ISession) ForumThreadStart(channelID string, name string, archiveDuration int, content string, options ...discordgo.RequestOption) (*discordgo.Channel, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, name, archiveDuration, content)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ForumThreadStart")
	}

	var r0 *discordgo.Channel
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, int, string, ...discordgo.RequestOption) (*discordgo.Channel, error)); ok {
		return rf(channelID, name, archiveDuration, content, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, int, string, ...discordgo.RequestOption) *discordgo.Channel); ok {
		r0 = rf(channelID, name, archiveDuration, content, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Channel)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, int, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, name, archiveDuration, content, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ForumThreadStartComplex provides a mock function with given fields: channelID, threadData, messageData, options
func (_m *ISession) ForumThreadStartComplex(channelID string, threadData *discordgo.ThreadStart, messageData *discordgo.MessageSend, options ...discordgo.RequestOption) (*discordgo.Channel, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, threadData, messageData)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ForumThreadStartComplex")
	}

	var r0 *discordgo.Channel
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *discordgo.ThreadStart, *discordgo.MessageSend, ...discordgo.RequestOption) (*discordgo.Channel, error)); ok {
		return rf(channelID, threadData, messageData, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *discordgo.ThreadStart, *discordgo.MessageSend, ...discordgo.RequestOption) *discordgo.Channel); ok {
		r0 = rf(channelID, threadData, messageData, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Channel)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *discordgo.ThreadStart, *discordgo.MessageSend, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, threadData, messageData, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ForumThreadStartEmbed provides a mock function with given fields: channelID, name, archiveDuration, embed, options
func (_m *ISession) ForumThreadStartEmbed(channelID string, name string, archiveDuration int, embed *discordgo.MessageEmbed, options ...discordgo.RequestOption) (*discordgo.Channel, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, name, archiveDuration, embed)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ForumThreadStartEmbed")
	}

	var r0 *discordgo.Channel
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, int, *discordgo.MessageEmbed, ...discordgo.RequestOption) (*discordgo.Channel, error)); ok {
		return rf(channelID, name, archiveDuration, embed, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, int, *discordgo.MessageEmbed, ...discordgo.RequestOption) *discordgo.Channel); ok {
		r0 = rf(channelID, name, archiveDuration, embed, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Channel)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, int, *discordgo.MessageEmbed, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, name, archiveDuration, embed, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ForumThreadStartEmbeds provides a mock function with given fields: channelID, name, archiveDuration, embeds, options
func (_m *ISession) ForumThreadStartEmbeds(channelID string, name string, archiveDuration int, embeds []*discordgo.MessageEmbed, options ...discordgo.RequestOption) (*discordgo.Channel, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, name, archiveDuration, embeds)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ForumThreadStartEmbeds")
	}

	var r0 *discordgo.Channel
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, int, []*discordgo.MessageEmbed, ...discordgo.RequestOption) (*discordgo.Channel, error)); ok {
		return rf(channelID, name, archiveDuration, embeds, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, int, []*discordgo.MessageEmbed, ...discordgo.RequestOption) *discordgo.Channel); ok {
		r0 = rf(channelID, name, archiveDuration, embeds, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Channel)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, int, []*discordgo.MessageEmbed, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, name, archiveDuration, embeds, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Gateway provides a mock function with given fields: options
func (_m *ISession) Gateway(options ...discordgo.RequestOption) (string, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Gateway")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(...discordgo.RequestOption) (string, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...discordgo.RequestOption) string); ok {
		r0 = rf(options...)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(...discordgo.RequestOption) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GatewayBot provides a mock function with given fields: options
func (_m *ISession) GatewayBot(options ...discordgo.RequestOption) (*discordgo.GatewayBotResponse, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GatewayBot")
	}

	var r0 *discordgo.GatewayBotResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(...discordgo.RequestOption) (*discordgo.GatewayBotResponse, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...discordgo.RequestOption) *discordgo.GatewayBotResponse); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.GatewayBotResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(...discordgo.RequestOption) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Guild provides a mock function with given fields: guildID, options
func (_m *ISession) Guild(guildID string, options ...discordgo.RequestOption) (*discordgo.Guild, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Guild")
	}

	var r0 *discordgo.Guild
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) (*discordgo.Guild, error)); ok {
		return rf(guildID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) *discordgo.Guild); ok {
		r0 = rf(guildID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Guild)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildApplicationCommandsPermissions provides a mock function with given fields: appID, guildID, options
func (_m *ISession) GuildApplicationCommandsPermissions(appID string, guildID string, options ...discordgo.RequestOption) ([]*discordgo.GuildApplicationCommandPermissions, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, appID, guildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildApplicationCommandsPermissions")
	}

	var r0 []*discordgo.GuildApplicationCommandPermissions
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) ([]*discordgo.GuildApplicationCommandPermissions, error)); ok {
		return rf(appID, guildID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) []*discordgo.GuildApplicationCommandPermissions); ok {
		r0 = rf(appID, guildID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.GuildApplicationCommandPermissions)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(appID, guildID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildAuditLog provides a mock function with given fields: guildID, userID, beforeID, actionType, limit, options
func (_m *ISession) GuildAuditLog(guildID string, userID string, beforeID string, actionType int, limit int, options ...discordgo.RequestOption) (*discordgo.GuildAuditLog, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, userID, beforeID, actionType, limit)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildAuditLog")
	}

	var r0 *discordgo.GuildAuditLog
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, int, int, ...discordgo.RequestOption) (*discordgo.GuildAuditLog, error)); ok {
		return rf(guildID, userID, beforeID, actionType, limit, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, int, int, ...discordgo.RequestOption) *discordgo.GuildAuditLog); ok {
		r0 = rf(guildID, userID, beforeID, actionType, limit, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.GuildAuditLog)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, int, int, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, userID, beforeID, actionType, limit, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildBan provides a mock function with given fields: guildID, userID, options
func (_m *ISession) GuildBan(guildID string, userID string, options ...discordgo.RequestOption) (*discordgo.GuildBan, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, userID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildBan")
	}

	var r0 *discordgo.GuildBan
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) (*discordgo.GuildBan, error)); ok {
		return rf(guildID, userID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) *discordgo.GuildBan); ok {
		r0 = rf(guildID, userID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.GuildBan)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, userID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildBanCreate provides a mock function with given fields: guildID, userID, days, options
func (_m *ISession) GuildBanCreate(guildID string, userID string, days int, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, userID, days)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildBanCreate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, int, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, userID, days, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GuildBanCreateWithReason provides a mock function with given fields: guildID, userID, reason, days, options
func (_m *ISession) GuildBanCreateWithReason(guildID string, userID string, reason string, days int, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, userID, reason, days)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildBanCreateWithReason")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, int, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, userID, reason, days, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GuildBanDelete provides a mock function with given fields: guildID, userID, options
func (_m *ISession) GuildBanDelete(guildID string, userID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, userID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildBanDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, userID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GuildBans provides a mock function with given fields: guildID, limit, beforeID, afterID, options
func (_m *ISession) GuildBans(guildID string, limit int, beforeID string, afterID string, options ...discordgo.RequestOption) ([]*discordgo.GuildBan, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, limit, beforeID, afterID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildBans")
	}

	var r0 []*discordgo.GuildBan
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int, string, string, ...discordgo.RequestOption) ([]*discordgo.GuildBan, error)); ok {
		return rf(guildID, limit, beforeID, afterID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, int, string, string, ...discordgo.RequestOption) []*discordgo.GuildBan); ok {
		r0 = rf(guildID, limit, beforeID, afterID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.GuildBan)
		}
	}

	if rf, ok := ret.Get(1).(func(string, int, string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, limit, beforeID, afterID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildChannelCreate provides a mock function with given fields: guildID, name, ctype, options
func (_m *ISession) GuildChannelCreate(guildID string, name string, ctype discordgo.ChannelType, options ...discordgo.RequestOption) (*discordgo.Channel, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, name, ctype)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildChannelCreate")
	}

	var r0 *discordgo.Channel
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, discordgo.ChannelType, ...discordgo.RequestOption) (*discordgo.Channel, error)); ok {
		return rf(guildID, name, ctype, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, discordgo.ChannelType, ...discordgo.RequestOption) *discordgo.Channel); ok {
		r0 = rf(guildID, name, ctype, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Channel)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, discordgo.ChannelType, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, name, ctype, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildChannelCreateComplex provides a mock function with given fields: guildID, data, options
func (_m *ISession) GuildChannelCreateComplex(guildID string, data discordgo.GuildChannelCreateData, options ...discordgo.RequestOption) (*discordgo.Channel, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildChannelCreateComplex")
	}

	var r0 *discordgo.Channel
	var r1 error
	if rf, ok := ret.Get(0).(func(string, discordgo.GuildChannelCreateData, ...discordgo.RequestOption) (*discordgo.Channel, error)); ok {
		return rf(guildID, data, options...)
	}
	if rf, ok := ret.Get(0).(func(string, discordgo.GuildChannelCreateData, ...discordgo.RequestOption) *discordgo.Channel); ok {
		r0 = rf(guildID, data, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Channel)
		}
	}

	if rf, ok := ret.Get(1).(func(string, discordgo.GuildChannelCreateData, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, data, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildChannels provides a mock function with given fields: guildID, options
func (_m *ISession) GuildChannels(guildID string, options ...discordgo.RequestOption) ([]*discordgo.Channel, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildChannels")
	}

	var r0 []*discordgo.Channel
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) ([]*discordgo.Channel, error)); ok {
		return rf(guildID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) []*discordgo.Channel); ok {
		r0 = rf(guildID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.Channel)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildChannelsReorder provides a mock function with given fields: guildID, channels, options
func (_m *ISession) GuildChannelsReorder(guildID string, channels []*discordgo.Channel, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, channels)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildChannelsReorder")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, []*discordgo.Channel, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, channels, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GuildCreate provides a mock function with given fields: name, options
func (_m *ISession) GuildCreate(name string, options ...discordgo.RequestOption) (*discordgo.Guild, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildCreate")
	}

	var r0 *discordgo.Guild
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) (*discordgo.Guild, error)); ok {
		return rf(name, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) *discordgo.Guild); ok {
		r0 = rf(name, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Guild)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(name, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildCreateWithTemplate provides a mock function with given fields: templateCode, name, icon, options
func (_m *ISession) GuildCreateWithTemplate(templateCode string, name string, icon string, options ...discordgo.RequestOption) (*discordgo.Guild, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, templateCode, name, icon)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildCreateWithTemplate")
	}

	var r0 *discordgo.Guild
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, ...discordgo.RequestOption) (*discordgo.Guild, error)); ok {
		return rf(templateCode, name, icon, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, ...discordgo.RequestOption) *discordgo.Guild); ok {
		r0 = rf(templateCode, name, icon, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Guild)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(templateCode, name, icon, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildDelete provides a mock function with given fields: guildID, options
func (_m *ISession) GuildDelete(guildID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GuildEdit provides a mock function with given fields: guildID, g, options
func (_m *ISession) GuildEdit(guildID string, g *discordgo.GuildParams, options ...discordgo.RequestOption) (*discordgo.Guild, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, g)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildEdit")
	}

	var r0 *discordgo.Guild
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *discordgo.GuildParams, ...discordgo.RequestOption) (*discordgo.Guild, error)); ok {
		return rf(guildID, g, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *discordgo.GuildParams, ...discordgo.RequestOption) *discordgo.Guild); ok {
		r0 = rf(guildID, g, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Guild)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *discordgo.GuildParams, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, g, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildEmbed provides a mock function with given fields: guildID, options
func (_m *ISession) GuildEmbed(guildID string, options ...discordgo.RequestOption) (*discordgo.GuildEmbed, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildEmbed")
	}

	var r0 *discordgo.GuildEmbed
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) (*discordgo.GuildEmbed, error)); ok {
		return rf(guildID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) *discordgo.GuildEmbed); ok {
		r0 = rf(guildID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.GuildEmbed)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildEmbedEdit provides a mock function with given fields: guildID, data, options
func (_m *ISession) GuildEmbedEdit(guildID string, data *discordgo.GuildEmbed, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildEmbedEdit")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, *discordgo.GuildEmbed, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, data, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GuildEmoji provides a mock function with given fields: guildID, emojiID, options
func (_m *ISession) GuildEmoji(guildID string, emojiID string, options ...discordgo.RequestOption) (*discordgo.Emoji, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, emojiID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildEmoji")
	}

	var r0 *discordgo.Emoji
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) (*discordgo.Emoji, error)); ok {
		return rf(guildID, emojiID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) *discordgo.Emoji); ok {
		r0 = rf(guildID, emojiID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Emoji)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, emojiID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildEmojiCreate provides a mock function with given fields: guildID, data, options
func (_m *ISession) GuildEmojiCreate(guildID string, data *discordgo.EmojiParams, options ...discordgo.RequestOption) (*discordgo.Emoji, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildEmojiCreate")
	}

	var r0 *discordgo.Emoji
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *discordgo.EmojiParams, ...discordgo.RequestOption) (*discordgo.Emoji, error)); ok {
		return rf(guildID, data, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *discordgo.EmojiParams, ...discordgo.RequestOption) *discordgo.Emoji); ok {
		r0 = rf(guildID, data, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Emoji)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *discordgo.EmojiParams, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, data, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildEmojiDelete provides a mock function with given fields: guildID, emojiID, options
func (_m *ISession) GuildEmojiDelete(guildID string, emojiID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, emojiID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildEmojiDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, emojiID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GuildEmojiEdit provides a mock function with given fields: guildID, emojiID, data, options
func (_m *ISession) GuildEmojiEdit(guildID string, emojiID string, data *discordgo.EmojiParams, options ...discordgo.RequestOption) (*discordgo.Emoji, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, emojiID, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildEmojiEdit")
	}

	var r0 *discordgo.Emoji
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, *discordgo.EmojiParams, ...discordgo.RequestOption) (*discordgo.Emoji, error)); ok {
		return rf(guildID, emojiID, data, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, *discordgo.EmojiParams, ...discordgo.RequestOption) *discordgo.Emoji); ok {
		r0 = rf(guildID, emojiID, data, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Emoji)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, *discordgo.EmojiParams, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, emojiID, data, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildEmojis provides a mock function with given fields: guildID, options
func (_m *ISession) GuildEmojis(guildID string, options ...discordgo.RequestOption) ([]*discordgo.Emoji, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildEmojis")
	}

	var r0 []*discordgo.Emoji
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) ([]*discordgo.Emoji, error)); ok {
		return rf(guildID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) []*discordgo.Emoji); ok {
		r0 = rf(guildID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.Emoji)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildIcon provides a mock function with given fields: guildID, options
func (_m *ISession) GuildIcon(guildID string, options ...discordgo.RequestOption) (image.Image, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildIcon")
	}

	var r0 image.Image
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) (image.Image, error)); ok {
		return rf(guildID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) image.Image); ok {
		r0 = rf(guildID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(image.Image)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildIntegrationCreate provides a mock function with given fields: guildID, integrationType, integrationID, options
func (_m *ISession) GuildIntegrationCreate(guildID string, integrationType string, integrationID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, integrationType, integrationID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildIntegrationCreate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, integrationType, integrationID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GuildIntegrationDelete provides a mock function with given fields: guildID, integrationID, options
func (_m *ISession) GuildIntegrationDelete(guildID string, integrationID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, integrationID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildIntegrationDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, integrationID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GuildIntegrationEdit provides a mock function with given fields: guildID, integrationID, expireBehavior, expireGracePeriod, enableEmoticons, options
func (_m *ISession) GuildIntegrationEdit(guildID string, integrationID string, expireBehavior int, expireGracePeriod int, enableEmoticons bool, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, integrationID, expireBehavior, expireGracePeriod, enableEmoticons)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildIntegrationEdit")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, int, int, bool, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, integrationID, expireBehavior, expireGracePeriod, enableEmoticons, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GuildIntegrations provides a mock function with given fields: guildID, options
func (_m *ISession) GuildIntegrations(guildID string, options ...discordgo.RequestOption) ([]*discordgo.Integration, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildIntegrations")
	}

	var r0 []*discordgo.Integration
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) ([]*discordgo.Integration, error)); ok {
		return rf(guildID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) []*discordgo.Integration); ok {
		r0 = rf(guildID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.Integration)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildInvites provides a mock function with given fields: guildID, options
func (_m *ISession) GuildInvites(guildID string, options ...discordgo.RequestOption) ([]*discordgo.Invite, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildInvites")
	}

	var r0 []*discordgo.Invite
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) ([]*discordgo.Invite, error)); ok {
		return rf(guildID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) []*discordgo.Invite); ok {
		r0 = rf(guildID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.Invite)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildLeave provides a mock function with given fields: guildID, options
func (_m *ISession) GuildLeave(guildID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildLeave")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GuildMember provides a mock function with given fields: guildID, userID, options
func (_m *ISession) GuildMember(guildID string, userID string, options ...discordgo.RequestOption) (*discordgo.Member, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, userID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildMember")
	}

	var r0 *discordgo.Member
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) (*discordgo.Member, error)); ok {
		return rf(guildID, userID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) *discordgo.Member); ok {
		r0 = rf(guildID, userID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Member)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, userID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildMemberAdd provides a mock function with given fields: guildID, userID, data, options
func (_m *ISession) GuildMemberAdd(guildID string, userID string, data *discordgo.GuildMemberAddParams, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, userID, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildMemberAdd")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, *discordgo.GuildMemberAddParams, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, userID, data, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GuildMemberDeafen provides a mock function with given fields: guildID, userID, deaf, options
func (_m *ISession) GuildMemberDeafen(guildID string, userID string, deaf bool, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, userID, deaf)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildMemberDeafen")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, bool, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, userID, deaf, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GuildMemberDelete provides a mock function with given fields: guildID, userID, options
func (_m *ISession) GuildMemberDelete(guildID string, userID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, userID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildMemberDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, userID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GuildMemberDeleteWithReason provides a mock function with given fields: guildID, userID, reason, options
func (_m *ISession) GuildMemberDeleteWithReason(guildID string, userID string, reason string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, userID, reason)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildMemberDeleteWithReason")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, userID, reason, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GuildMemberEdit provides a mock function with given fields: guildID, userID, data, options
func (_m *ISession) GuildMemberEdit(guildID string, userID string, data *discordgo.GuildMemberParams, options ...discordgo.RequestOption) (*discordgo.Member, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, userID, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildMemberEdit")
	}

	var r0 *discordgo.Member
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, *discordgo.GuildMemberParams, ...discordgo.RequestOption) (*discordgo.Member, error)); ok {
		return rf(guildID, userID, data, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, *discordgo.GuildMemberParams, ...discordgo.RequestOption) *discordgo.Member); ok {
		r0 = rf(guildID, userID, data, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Member)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, *discordgo.GuildMemberParams, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, userID, data, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildMemberEditComplex provides a mock function with given fields: guildID, userID, data, options
func (_m *ISession) GuildMemberEditComplex(guildID string, userID string, data *discordgo.GuildMemberParams, options ...discordgo.RequestOption) (*discordgo.Member, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, userID, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildMemberEditComplex")
	}

	var r0 *discordgo.Member
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, *discordgo.GuildMemberParams, ...discordgo.RequestOption) (*discordgo.Member, error)); ok {
		return rf(guildID, userID, data, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, *discordgo.GuildMemberParams, ...discordgo.RequestOption) *discordgo.Member); ok {
		r0 = rf(guildID, userID, data, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Member)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, *discordgo.GuildMemberParams, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, userID, data, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildMemberMove provides a mock function with given fields: guildID, userID, channelID, options
func (_m *ISession) GuildMemberMove(guildID string, userID string, channelID *string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, userID, channelID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildMemberMove")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, *string, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, userID, channelID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GuildMemberMute provides a mock function with given fields: guildID, userID, mute, options
func (_m *ISession) GuildMemberMute(guildID string, userID string, mute bool, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, userID, mute)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildMemberMute")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, bool, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, userID, mute, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GuildMemberNickname provides a mock function with given fields: guildID, userID, nickname, options
func (_m *ISession) GuildMemberNickname(guildID string, userID string, nickname string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, userID, nickname)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildMemberNickname")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, userID, nickname, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GuildMemberRoleAdd provides a mock function with given fields: guildID, userID, roleID, options
func (_m *ISession) GuildMemberRoleAdd(guildID string, userID string, roleID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, userID, roleID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildMemberRoleAdd")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, userID, roleID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GuildMemberRoleRemove provides a mock function with given fields: guildID, userID, roleID, options
func (_m *ISession) GuildMemberRoleRemove(guildID string, userID string, roleID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, userID, roleID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildMemberRoleRemove")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, userID, roleID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GuildMemberTimeout provides a mock function with given fields: guildID, userID, until, options
func (_m *ISession) GuildMemberTimeout(guildID string, userID string, until *time.Time, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, userID, until)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildMemberTimeout")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, *time.Time, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, userID, until, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GuildMembers provides a mock function with given fields: guildID, after, limit, options
func (_m *ISession) GuildMembers(guildID string, after string, limit int, options ...discordgo.RequestOption) ([]*discordgo.Member, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, after, limit)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildMembers")
	}

	var r0 []*discordgo.Member
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, int, ...discordgo.RequestOption) ([]*discordgo.Member, error)); ok {
		return rf(guildID, after, limit, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, int, ...discordgo.RequestOption) []*discordgo.Member); ok {
		r0 = rf(guildID, after, limit, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.Member)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, int, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, after, limit, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildMembersSearch provides a mock function with given fields: guildID, query, limit, options
func (_m *ISession) GuildMembersSearch(guildID string, query string, limit int, options ...discordgo.RequestOption) ([]*discordgo.Member, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, query, limit)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildMembersSearch")
	}

	var r0 []*discordgo.Member
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, int, ...discordgo.RequestOption) ([]*discordgo.Member, error)); ok {
		return rf(guildID, query, limit, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, int, ...discordgo.RequestOption) []*discordgo.Member); ok {
		r0 = rf(guildID, query, limit, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.Member)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, int, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, query, limit, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildOnboarding provides a mock function with given fields: guildID, options
func (_m *ISession) GuildOnboarding(guildID string, options ...discordgo.RequestOption) (*discordgo.GuildOnboarding, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildOnboarding")
	}

	var r0 *discordgo.GuildOnboarding
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) (*discordgo.GuildOnboarding, error)); ok {
		return rf(guildID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) *discordgo.GuildOnboarding); ok {
		r0 = rf(guildID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.GuildOnboarding)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildOnboardingEdit provides a mock function with given fields: guildID, o, options
func (_m *ISession) GuildOnboardingEdit(guildID string, o *discordgo.GuildOnboarding, options ...discordgo.RequestOption) (*discordgo.GuildOnboarding, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, o)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildOnboardingEdit")
	}

	var r0 *discordgo.GuildOnboarding
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *discordgo.GuildOnboarding, ...discordgo.RequestOption) (*discordgo.GuildOnboarding, error)); ok {
		return rf(guildID, o, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *discordgo.GuildOnboarding, ...discordgo.RequestOption) *discordgo.GuildOnboarding); ok {
		r0 = rf(guildID, o, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.GuildOnboarding)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *discordgo.GuildOnboarding, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, o, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildPreview provides a mock function with given fields: guildID, options
func (_m *ISession) GuildPreview(guildID string, options ...discordgo.RequestOption) (*discordgo.GuildPreview, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildPreview")
	}

	var r0 *discordgo.GuildPreview
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) (*discordgo.GuildPreview, error)); ok {
		return rf(guildID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) *discordgo.GuildPreview); ok {
		r0 = rf(guildID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.GuildPreview)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildPrune provides a mock function with given fields: guildID, days, options
func (_m *ISession) GuildPrune(guildID string, days uint32, options ...discordgo.RequestOption) (uint32, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, days)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildPrune")
	}

	var r0 uint32
	var r1 error
	if rf, ok := ret.Get(0).(func(string, uint32, ...discordgo.RequestOption) (uint32, error)); ok {
		return rf(guildID, days, options...)
	}
	if rf, ok := ret.Get(0).(func(string, uint32, ...discordgo.RequestOption) uint32); ok {
		r0 = rf(guildID, days, options...)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	if rf, ok := ret.Get(1).(func(string, uint32, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, days, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildPruneCount provides a mock function with given fields: guildID, days, options
func (_m *ISession) GuildPruneCount(guildID string, days uint32, options ...discordgo.RequestOption) (uint32, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, days)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildPruneCount")
	}

	var r0 uint32
	var r1 error
	if rf, ok := ret.Get(0).(func(string, uint32, ...discordgo.RequestOption) (uint32, error)); ok {
		return rf(guildID, days, options...)
	}
	if rf, ok := ret.Get(0).(func(string, uint32, ...discordgo.RequestOption) uint32); ok {
		r0 = rf(guildID, days, options...)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	if rf, ok := ret.Get(1).(func(string, uint32, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, days, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildRoleCreate provides a mock function with given fields: guildID, data, options
func (_m *ISession) GuildRoleCreate(guildID string, data *discordgo.RoleParams, options ...discordgo.RequestOption) (*discordgo.Role, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildRoleCreate")
	}

	var r0 *discordgo.Role
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *discordgo.RoleParams, ...discordgo.RequestOption) (*discordgo.Role, error)); ok {
		return rf(guildID, data, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *discordgo.RoleParams, ...discordgo.RequestOption) *discordgo.Role); ok {
		r0 = rf(guildID, data, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Role)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *discordgo.RoleParams, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, data, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildRoleDelete provides a mock function with given fields: guildID, roleID, options
func (_m *ISession) GuildRoleDelete(guildID string, roleID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, roleID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildRoleDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, roleID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GuildRoleEdit provides a mock function with given fields: guildID, roleID, data, options
func (_m *ISession) GuildRoleEdit(guildID string, roleID string, data *discordgo.RoleParams, options ...discordgo.RequestOption) (*discordgo.Role, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, roleID, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildRoleEdit")
	}

	var r0 *discordgo.Role
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, *discordgo.RoleParams, ...discordgo.RequestOption) (*discordgo.Role, error)); ok {
		return rf(guildID, roleID, data, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, *discordgo.RoleParams, ...discordgo.RequestOption) *discordgo.Role); ok {
		r0 = rf(guildID, roleID, data, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Role)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, *discordgo.RoleParams, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, roleID, data, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildRoleReorder provides a mock function with given fields: guildID, roles, options
func (_m *ISession) GuildRoleReorder(guildID string, roles []*discordgo.Role, options ...discordgo.RequestOption) ([]*discordgo.Role, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, roles)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildRoleReorder")
	}

	var r0 []*discordgo.Role
	var r1 error
	if rf, ok := ret.Get(0).(func(string, []*discordgo.Role, ...discordgo.RequestOption) ([]*discordgo.Role, error)); ok {
		return rf(guildID, roles, options...)
	}
	if rf, ok := ret.Get(0).(func(string, []*discordgo.Role, ...discordgo.RequestOption) []*discordgo.Role); ok {
		r0 = rf(guildID, roles, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.Role)
		}
	}

	if rf, ok := ret.Get(1).(func(string, []*discordgo.Role, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, roles, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildRoles provides a mock function with given fields: guildID, options
func (_m *ISession) GuildRoles(guildID string, options ...discordgo.RequestOption) ([]*discordgo.Role, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildRoles")
	}

	var r0 []*discordgo.Role
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) ([]*discordgo.Role, error)); ok {
		return rf(guildID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) []*discordgo.Role); ok {
		r0 = rf(guildID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.Role)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildScheduledEvent provides a mock function with given fields: guildID, eventID, userCount, options
func (_m *ISession) GuildScheduledEvent(guildID string, eventID string, userCount bool, options ...discordgo.RequestOption) (*discordgo.GuildScheduledEvent, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, eventID, userCount)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildScheduledEvent")
	}

	var r0 *discordgo.GuildScheduledEvent
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, bool, ...discordgo.RequestOption) (*discordgo.GuildScheduledEvent, error)); ok {
		return rf(guildID, eventID, userCount, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, bool, ...discordgo.RequestOption) *discordgo.GuildScheduledEvent); ok {
		r0 = rf(guildID, eventID, userCount, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.GuildScheduledEvent)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, bool, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, eventID, userCount, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildScheduledEventCreate provides a mock function with given fields: guildID, event, options
func (_m *ISession) GuildScheduledEventCreate(guildID string, event *discordgo.GuildScheduledEventParams, options ...discordgo.RequestOption) (*discordgo.GuildScheduledEvent, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, event)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildScheduledEventCreate")
	}

	var r0 *discordgo.GuildScheduledEvent
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *discordgo.GuildScheduledEventParams, ...discordgo.RequestOption) (*discordgo.GuildScheduledEvent, error)); ok {
		return rf(guildID, event, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *discordgo.GuildScheduledEventParams, ...discordgo.RequestOption) *discordgo.GuildScheduledEvent); ok {
		r0 = rf(guildID, event, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.GuildScheduledEvent)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *discordgo.GuildScheduledEventParams, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, event, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildScheduledEventDelete provides a mock function with given fields: guildID, eventID, options
func (_m *ISession) GuildScheduledEventDelete(guildID string, eventID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, eventID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildScheduledEventDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, eventID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GuildScheduledEventEdit provides a mock function with given fields: guildID, eventID, event, options
func (_m *ISession) GuildScheduledEventEdit(guildID string, eventID string, event *discordgo.GuildScheduledEventParams, options ...discordgo.RequestOption) (*discordgo.GuildScheduledEvent, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, eventID, event)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildScheduledEventEdit")
	}

	var r0 *discordgo.GuildScheduledEvent
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, *discordgo.GuildScheduledEventParams, ...discordgo.RequestOption) (*discordgo.GuildScheduledEvent, error)); ok {
		return rf(guildID, eventID, event, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, *discordgo.GuildScheduledEventParams, ...discordgo.RequestOption) *discordgo.GuildScheduledEvent); ok {
		r0 = rf(guildID, eventID, event, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.GuildScheduledEvent)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, *discordgo.GuildScheduledEventParams, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, eventID, event, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildScheduledEventUsers provides a mock function with given fields: guildID, eventID, limit, withMember, beforeID, afterID, options
func (_m *ISession) GuildScheduledEventUsers(guildID string, eventID string, limit int, withMember bool, beforeID string, afterID string, options ...discordgo.RequestOption) ([]*discordgo.GuildScheduledEventUser, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, eventID, limit, withMember, beforeID, afterID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildScheduledEventUsers")
	}

	var r0 []*discordgo.GuildScheduledEventUser
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, int, bool, string, string, ...discordgo.RequestOption) ([]*discordgo.GuildScheduledEventUser, error)); ok {
		return rf(guildID, eventID, limit, withMember, beforeID, afterID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, int, bool, string, string, ...discordgo.RequestOption) []*discordgo.GuildScheduledEventUser); ok {
		r0 = rf(guildID, eventID, limit, withMember, beforeID, afterID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.GuildScheduledEventUser)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, int, bool, string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, eventID, limit, withMember, beforeID, afterID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildScheduledEvents provides a mock function with given fields: guildID, userCount, options
func (_m *ISession) GuildScheduledEvents(guildID string, userCount bool, options ...discordgo.RequestOption) ([]*discordgo.GuildScheduledEvent, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, userCount)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildScheduledEvents")
	}

	var r0 []*discordgo.GuildScheduledEvent
	var r1 error
	if rf, ok := ret.Get(0).(func(string, bool, ...discordgo.RequestOption) ([]*discordgo.GuildScheduledEvent, error)); ok {
		return rf(guildID, userCount, options...)
	}
	if rf, ok := ret.Get(0).(func(string, bool, ...discordgo.RequestOption) []*discordgo.GuildScheduledEvent); ok {
		r0 = rf(guildID, userCount, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.GuildScheduledEvent)
		}
	}

	if rf, ok := ret.Get(1).(func(string, bool, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, userCount, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildSplash provides a mock function with given fields: guildID, options
func (_m *ISession) GuildSplash(guildID string, options ...discordgo.RequestOption) (image.Image, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildSplash")
	}

	var r0 image.Image
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) (image.Image, error)); ok {
		return rf(guildID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) image.Image); ok {
		r0 = rf(guildID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(image.Image)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildTemplate provides a mock function with given fields: templateCode, options
func (_m *ISession) GuildTemplate(templateCode string, options ...discordgo.RequestOption) (*discordgo.GuildTemplate, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, templateCode)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildTemplate")
	}

	var r0 *discordgo.GuildTemplate
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) (*discordgo.GuildTemplate, error)); ok {
		return rf(templateCode, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) *discordgo.GuildTemplate); ok {
		r0 = rf(templateCode, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.GuildTemplate)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(templateCode, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildTemplateCreate provides a mock function with given fields: guildID, data, options
func (_m *ISession) GuildTemplateCreate(guildID string, data *discordgo.GuildTemplateParams, options ...discordgo.RequestOption) *discordgo.GuildTemplate {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildTemplateCreate")
	}

	var r0 *discordgo.GuildTemplate
	if rf, ok := ret.Get(0).(func(string, *discordgo.GuildTemplateParams, ...discordgo.RequestOption) *discordgo.GuildTemplate); ok {
		r0 = rf(guildID, data, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.GuildTemplate)
		}
	}

	return r0
}

// GuildTemplateDelete provides a mock function with given fields: guildID, templateCode, options
func (_m *ISession) GuildTemplateDelete(guildID string, templateCode string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, templateCode)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildTemplateDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, templateCode, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GuildTemplateEdit provides a mock function with given fields: guildID, templateCode, data, options
func (_m *ISession) GuildTemplateEdit(guildID string, templateCode string, data *discordgo.GuildTemplateParams, options ...discordgo.RequestOption) (*discordgo.GuildTemplate, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, templateCode, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildTemplateEdit")
	}

	var r0 *discordgo.GuildTemplate
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, *discordgo.GuildTemplateParams, ...discordgo.RequestOption) (*discordgo.GuildTemplate, error)); ok {
		return rf(guildID, templateCode, data, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, *discordgo.GuildTemplateParams, ...discordgo.RequestOption) *discordgo.GuildTemplate); ok {
		r0 = rf(guildID, templateCode, data, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.GuildTemplate)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, *discordgo.GuildTemplateParams, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, templateCode, data, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildTemplateSync provides a mock function with given fields: guildID, templateCode, options
func (_m *ISession) GuildTemplateSync(guildID string, templateCode string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID, templateCode)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildTemplateSync")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(guildID, templateCode, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GuildTemplates provides a mock function with given fields: guildID, options
func (_m *ISession) GuildTemplates(guildID string, options ...discordgo.RequestOption) ([]*discordgo.GuildTemplate, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildTemplates")
	}

	var r0 []*discordgo.GuildTemplate
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) ([]*discordgo.GuildTemplate, error)); ok {
		return rf(guildID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) []*discordgo.GuildTemplate); ok {
		r0 = rf(guildID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.GuildTemplate)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildThreadsActive provides a mock function with given fields: guildID, options
func (_m *ISession) GuildThreadsActive(guildID string, options ...discordgo.RequestOption) (*discordgo.ThreadsList, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildThreadsActive")
	}

	var r0 *discordgo.ThreadsList
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) (*discordgo.ThreadsList, error)); ok {
		return rf(guildID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) *discordgo.ThreadsList); ok {
		r0 = rf(guildID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.ThreadsList)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildWebhooks provides a mock function with given fields: guildID, options
func (_m *ISession) GuildWebhooks(guildID string, options ...discordgo.RequestOption) ([]*discordgo.Webhook, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildWebhooks")
	}

	var r0 []*discordgo.Webhook
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) ([]*discordgo.Webhook, error)); ok {
		return rf(guildID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) []*discordgo.Webhook); ok {
		r0 = rf(guildID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.Webhook)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GuildWithCounts provides a mock function with given fields: guildID, options
func (_m *ISession) GuildWithCounts(guildID string, options ...discordgo.RequestOption) (*discordgo.Guild, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GuildWithCounts")
	}

	var r0 *discordgo.Guild
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) (*discordgo.Guild, error)); ok {
		return rf(guildID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) *discordgo.Guild); ok {
		r0 = rf(guildID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Guild)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HeartbeatLatency provides a mock function with given fields:
func (_m *ISession) HeartbeatLatency() time.Duration {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for HeartbeatLatency")
	}

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// InteractionRespond provides a mock function with given fields: interaction, resp, options
func (_m *ISession) InteractionRespond(interaction *discordgo.Interaction, resp *discordgo.InteractionResponse, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, interaction, resp)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InteractionRespond")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*discordgo.Interaction, *discordgo.InteractionResponse, ...discordgo.RequestOption) error); ok {
		r0 = rf(interaction, resp, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InteractionResponse provides a mock function with given fields: interaction, options
func (_m *ISession) InteractionResponse(interaction *discordgo.Interaction, options ...discordgo.RequestOption) (*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, interaction)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InteractionResponse")
	}

	var r0 *discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(*discordgo.Interaction, ...discordgo.RequestOption) (*discordgo.Message, error)); ok {
		return rf(interaction, options...)
	}
	if rf, ok := ret.Get(0).(func(*discordgo.Interaction, ...discordgo.RequestOption) *discordgo.Message); ok {
		r0 = rf(interaction, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(*discordgo.Interaction, ...discordgo.RequestOption) error); ok {
		r1 = rf(interaction, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InteractionResponseDelete provides a mock function with given fields: interaction, options
func (_m *ISession) InteractionResponseDelete(interaction *discordgo.Interaction, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, interaction)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InteractionResponseDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*discordgo.Interaction, ...discordgo.RequestOption) error); ok {
		r0 = rf(interaction, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InteractionResponseEdit provides a mock function with given fields: interaction, newresp, options
func (_m *ISession) InteractionResponseEdit(interaction *discordgo.Interaction, newresp *discordgo.WebhookEdit, options ...discordgo.RequestOption) (*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, interaction, newresp)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InteractionResponseEdit")
	}

	var r0 *discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(*discordgo.Interaction, *discordgo.WebhookEdit, ...discordgo.RequestOption) (*discordgo.Message, error)); ok {
		return rf(interaction, newresp, options...)
	}
	if rf, ok := ret.Get(0).(func(*discordgo.Interaction, *discordgo.WebhookEdit, ...discordgo.RequestOption) *discordgo.Message); ok {
		r0 = rf(interaction, newresp, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(*discordgo.Interaction, *discordgo.WebhookEdit, ...discordgo.RequestOption) error); ok {
		r1 = rf(interaction, newresp, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Invite provides a mock function with given fields: inviteID, options
func (_m *ISession) Invite(inviteID string, options ...discordgo.RequestOption) (*discordgo.Invite, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, inviteID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Invite")
	}

	var r0 *discordgo.Invite
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) (*discordgo.Invite, error)); ok {
		return rf(inviteID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) *discordgo.Invite); ok {
		r0 = rf(inviteID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Invite)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(inviteID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InviteAccept provides a mock function with given fields: inviteID, options
func (_m *ISession) InviteAccept(inviteID string, options ...discordgo.RequestOption) (*discordgo.Invite, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, inviteID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InviteAccept")
	}

	var r0 *discordgo.Invite
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) (*discordgo.Invite, error)); ok {
		return rf(inviteID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) *discordgo.Invite); ok {
		r0 = rf(inviteID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Invite)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(inviteID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InviteComplex provides a mock function with given fields: inviteID, guildScheduledEventID, withCounts, withExpiration, options
func (_m *ISession) InviteComplex(inviteID string, guildScheduledEventID string, withCounts bool, withExpiration bool, options ...discordgo.RequestOption) (*discordgo.Invite, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, inviteID, guildScheduledEventID, withCounts, withExpiration)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InviteComplex")
	}

	var r0 *discordgo.Invite
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, bool, bool, ...discordgo.RequestOption) (*discordgo.Invite, error)); ok {
		return rf(inviteID, guildScheduledEventID, withCounts, withExpiration, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, bool, bool, ...discordgo.RequestOption) *discordgo.Invite); ok {
		r0 = rf(inviteID, guildScheduledEventID, withCounts, withExpiration, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Invite)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, bool, bool, ...discordgo.RequestOption) error); ok {
		r1 = rf(inviteID, guildScheduledEventID, withCounts, withExpiration, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InviteDelete provides a mock function with given fields: inviteID, options
func (_m *ISession) InviteDelete(inviteID string, options ...discordgo.RequestOption) (*discordgo.Invite, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, inviteID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InviteDelete")
	}

	var r0 *discordgo.Invite
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) (*discordgo.Invite, error)); ok {
		return rf(inviteID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) *discordgo.Invite); ok {
		r0 = rf(inviteID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Invite)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(inviteID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InviteWithCounts provides a mock function with given fields: inviteID, options
func (_m *ISession) InviteWithCounts(inviteID string, options ...discordgo.RequestOption) (*discordgo.Invite, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, inviteID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InviteWithCounts")
	}

	var r0 *discordgo.Invite
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) (*discordgo.Invite, error)); ok {
		return rf(inviteID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) *discordgo.Invite); ok {
		r0 = rf(inviteID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Invite)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(inviteID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MessageReactionAdd provides a mock function with given fields: channelID, messageID, emojiID, options
func (_m *ISession) MessageReactionAdd(channelID string, messageID string, emojiID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, messageID, emojiID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MessageReactionAdd")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(channelID, messageID, emojiID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MessageReactionRemove provides a mock function with given fields: channelID, messageID, emojiID, userID, options
func (_m *ISession) MessageReactionRemove(channelID string, messageID string, emojiID string, userID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, messageID, emojiID, userID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MessageReactionRemove")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(channelID, messageID, emojiID, userID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MessageReactions provides a mock function with given fields: channelID, messageID, emojiID, limit, beforeID, afterID, options
func (_m *ISession) MessageReactions(channelID string, messageID string, emojiID string, limit int, beforeID string, afterID string, options ...discordgo.RequestOption) ([]*discordgo.User, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, messageID, emojiID, limit, beforeID, afterID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MessageReactions")
	}

	var r0 []*discordgo.User
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, int, string, string, ...discordgo.RequestOption) ([]*discordgo.User, error)); ok {
		return rf(channelID, messageID, emojiID, limit, beforeID, afterID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, int, string, string, ...discordgo.RequestOption) []*discordgo.User); ok {
		r0 = rf(channelID, messageID, emojiID, limit, beforeID, afterID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.User)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, int, string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, messageID, emojiID, limit, beforeID, afterID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MessageReactionsRemoveAll provides a mock function with given fields: channelID, messageID, options
func (_m *ISession) MessageReactionsRemoveAll(channelID string, messageID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, messageID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MessageReactionsRemoveAll")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(channelID, messageID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MessageReactionsRemoveEmoji provides a mock function with given fields: channelID, messageID, emojiID, options
func (_m *ISession) MessageReactionsRemoveEmoji(channelID string, messageID string, emojiID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, messageID, emojiID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MessageReactionsRemoveEmoji")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(channelID, messageID, emojiID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MessageThreadStart provides a mock function with given fields: channelID, messageID, name, archiveDuration, options
func (_m *ISession) MessageThreadStart(channelID string, messageID string, name string, archiveDuration int, options ...discordgo.RequestOption) (*discordgo.Channel, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, messageID, name, archiveDuration)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MessageThreadStart")
	}

	var r0 *discordgo.Channel
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, int, ...discordgo.RequestOption) (*discordgo.Channel, error)); ok {
		return rf(channelID, messageID, name, archiveDuration, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, int, ...discordgo.RequestOption) *discordgo.Channel); ok {
		r0 = rf(channelID, messageID, name, archiveDuration, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Channel)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, int, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, messageID, name, archiveDuration, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MessageThreadStartComplex provides a mock function with given fields: channelID, messageID, data, options
func (_m *ISession) MessageThreadStartComplex(channelID string, messageID string, data *discordgo.ThreadStart, options ...discordgo.RequestOption) (*discordgo.Channel, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, messageID, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MessageThreadStartComplex")
	}

	var r0 *discordgo.Channel
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, *discordgo.ThreadStart, ...discordgo.RequestOption) (*discordgo.Channel, error)); ok {
		return rf(channelID, messageID, data, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, *discordgo.ThreadStart, ...discordgo.RequestOption) *discordgo.Channel); ok {
		r0 = rf(channelID, messageID, data, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Channel)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, *discordgo.ThreadStart, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, messageID, data, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Open provides a mock function with given fields:
func (_m *ISession) Open() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Open")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Request provides a mock function with given fields: method, urlStr, data, options
func (_m *ISession) Request(method string, urlStr string, data interface{}, options ...discordgo.RequestOption) ([]byte, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, method, urlStr, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Request")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, interface{}, ...discordgo.RequestOption) ([]byte, error)); ok {
		return rf(method, urlStr, data, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, interface{}, ...discordgo.RequestOption) []byte); ok {
		r0 = rf(method, urlStr, data, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, interface{}, ...discordgo.RequestOption) error); ok {
		r1 = rf(method, urlStr, data, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RequestGuildMembers provides a mock function with given fields: guildID, query, limit, nonce, presences
func (_m *ISession) RequestGuildMembers(guildID string, query string, limit int, nonce string, presences bool) error {
	ret := _m.Called(guildID, query, limit, nonce, presences)

	if len(ret) == 0 {
		panic("no return value specified for RequestGuildMembers")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, int, string, bool) error); ok {
		r0 = rf(guildID, query, limit, nonce, presences)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RequestGuildMembersBatch provides a mock function with given fields: guildIDs, query, limit, nonce, presences
func (_m *ISession) RequestGuildMembersBatch(guildIDs []string, query string, limit int, nonce string, presences bool) error {
	ret := _m.Called(guildIDs, query, limit, nonce, presences)

	if len(ret) == 0 {
		panic("no return value specified for RequestGuildMembersBatch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]string, string, int, string, bool) error); ok {
		r0 = rf(guildIDs, query, limit, nonce, presences)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RequestGuildMembersBatchList provides a mock function with given fields: guildIDs, userIDs, limit, nonce, presences
func (_m *ISession) RequestGuildMembersBatchList(guildIDs []string, userIDs []string, limit int, nonce string, presences bool) error {
	ret := _m.Called(guildIDs, userIDs, limit, nonce, presences)

	if len(ret) == 0 {
		panic("no return value specified for RequestGuildMembersBatchList")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]string, []string, int, string, bool) error); ok {
		r0 = rf(guildIDs, userIDs, limit, nonce, presences)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RequestGuildMembersList provides a mock function with given fields: guildID, userIDs, limit, nonce, presences
func (_m *ISession) RequestGuildMembersList(guildID string, userIDs []string, limit int, nonce string, presences bool) error {
	ret := _m.Called(guildID, userIDs, limit, nonce, presences)

	if len(ret) == 0 {
		panic("no return value specified for RequestGuildMembersList")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, []string, int, string, bool) error); ok {
		r0 = rf(guildID, userIDs, limit, nonce, presences)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RequestWithBucketID provides a mock function with given fields: method, urlStr, data, bucketID, options
func (_m *ISession) RequestWithBucketID(method string, urlStr string, data interface{}, bucketID string, options ...discordgo.RequestOption) ([]byte, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, method, urlStr, data, bucketID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RequestWithBucketID")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, interface{}, string, ...discordgo.RequestOption) ([]byte, error)); ok {
		return rf(method, urlStr, data, bucketID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, interface{}, string, ...discordgo.RequestOption) []byte); ok {
		r0 = rf(method, urlStr, data, bucketID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, interface{}, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(method, urlStr, data, bucketID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RequestWithLockedBucket provides a mock function with given fields: method, urlStr, contentType, b, bucket, sequence, options
func (_m *ISession) RequestWithLockedBucket(method string, urlStr string, contentType string, b []byte, bucket *discordgo.Bucket, sequence int, options ...discordgo.RequestOption) ([]byte, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, method, urlStr, contentType, b, bucket, sequence)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RequestWithLockedBucket")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, []byte, *discordgo.Bucket, int, ...discordgo.RequestOption) ([]byte, error)); ok {
		return rf(method, urlStr, contentType, b, bucket, sequence, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, []byte, *discordgo.Bucket, int, ...discordgo.RequestOption) []byte); ok {
		r0 = rf(method, urlStr, contentType, b, bucket, sequence, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, []byte, *discordgo.Bucket, int, ...discordgo.RequestOption) error); ok {
		r1 = rf(method, urlStr, contentType, b, bucket, sequence, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StageInstance provides a mock function with given fields: channelID, options
func (_m *ISession) StageInstance(channelID string, options ...discordgo.RequestOption) (*discordgo.StageInstance, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StageInstance")
	}

	var r0 *discordgo.StageInstance
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) (*discordgo.StageInstance, error)); ok {
		return rf(channelID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) *discordgo.StageInstance); ok {
		r0 = rf(channelID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.StageInstance)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StageInstanceCreate provides a mock function with given fields: data, options
func (_m *ISession) StageInstanceCreate(data *discordgo.StageInstanceParams, options ...discordgo.RequestOption) (*discordgo.StageInstance, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StageInstanceCreate")
	}

	var r0 *discordgo.StageInstance
	var r1 error
	if rf, ok := ret.Get(0).(func(*discordgo.StageInstanceParams, ...discordgo.RequestOption) (*discordgo.StageInstance, error)); ok {
		return rf(data, options...)
	}
	if rf, ok := ret.Get(0).(func(*discordgo.StageInstanceParams, ...discordgo.RequestOption) *discordgo.StageInstance); ok {
		r0 = rf(data, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.StageInstance)
		}
	}

	if rf, ok := ret.Get(1).(func(*discordgo.StageInstanceParams, ...discordgo.RequestOption) error); ok {
		r1 = rf(data, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StageInstanceDelete provides a mock function with given fields: channelID, options
func (_m *ISession) StageInstanceDelete(channelID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StageInstanceDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) error); ok {
		r0 = rf(channelID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StageInstanceEdit provides a mock function with given fields: channelID, data, options
func (_m *ISession) StageInstanceEdit(channelID string, data *discordgo.StageInstanceParams, options ...discordgo.RequestOption) (*discordgo.StageInstance, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StageInstanceEdit")
	}

	var r0 *discordgo.StageInstance
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *discordgo.StageInstanceParams, ...discordgo.RequestOption) (*discordgo.StageInstance, error)); ok {
		return rf(channelID, data, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *discordgo.StageInstanceParams, ...discordgo.RequestOption) *discordgo.StageInstance); ok {
		r0 = rf(channelID, data, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.StageInstance)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *discordgo.StageInstanceParams, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, data, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ThreadJoin provides a mock function with given fields: id, options
func (_m *ISession) ThreadJoin(id string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, id)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ThreadJoin")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) error); ok {
		r0 = rf(id, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ThreadLeave provides a mock function with given fields: id, options
func (_m *ISession) ThreadLeave(id string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, id)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ThreadLeave")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) error); ok {
		r0 = rf(id, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ThreadMember provides a mock function with given fields: threadID, memberID, withMember, options
func (_m *ISession) ThreadMember(threadID string, memberID string, withMember bool, options ...discordgo.RequestOption) (*discordgo.ThreadMember, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, threadID, memberID, withMember)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ThreadMember")
	}

	var r0 *discordgo.ThreadMember
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, bool, ...discordgo.RequestOption) (*discordgo.ThreadMember, error)); ok {
		return rf(threadID, memberID, withMember, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, bool, ...discordgo.RequestOption) *discordgo.ThreadMember); ok {
		r0 = rf(threadID, memberID, withMember, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.ThreadMember)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, bool, ...discordgo.RequestOption) error); ok {
		r1 = rf(threadID, memberID, withMember, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ThreadMemberAdd provides a mock function with given fields: threadID, memberID, options
func (_m *ISession) ThreadMemberAdd(threadID string, memberID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, threadID, memberID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ThreadMemberAdd")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(threadID, memberID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ThreadMemberRemove provides a mock function with given fields: threadID, memberID, options
func (_m *ISession) ThreadMemberRemove(threadID string, memberID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, threadID, memberID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ThreadMemberRemove")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(threadID, memberID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ThreadMembers provides a mock function with given fields: threadID, limit, withMember, afterID, options
func (_m *ISession) ThreadMembers(threadID string, limit int, withMember bool, afterID string, options ...discordgo.RequestOption) ([]*discordgo.ThreadMember, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, threadID, limit, withMember, afterID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ThreadMembers")
	}

	var r0 []*discordgo.ThreadMember
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int, bool, string, ...discordgo.RequestOption) ([]*discordgo.ThreadMember, error)); ok {
		return rf(threadID, limit, withMember, afterID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, int, bool, string, ...discordgo.RequestOption) []*discordgo.ThreadMember); ok {
		r0 = rf(threadID, limit, withMember, afterID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.ThreadMember)
		}
	}

	if rf, ok := ret.Get(1).(func(string, int, bool, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(threadID, limit, withMember, afterID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ThreadStart provides a mock function with given fields: channelID, name, typ, archiveDuration, options
func (_m *ISession) ThreadStart(channelID string, name string, typ discordgo.ChannelType, archiveDuration int, options ...discordgo.RequestOption) (*discordgo.Channel, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, name, typ, archiveDuration)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ThreadStart")
	}

	var r0 *discordgo.Channel
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, discordgo.ChannelType, int, ...discordgo.RequestOption) (*discordgo.Channel, error)); ok {
		return rf(channelID, name, typ, archiveDuration, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, discordgo.ChannelType, int, ...discordgo.RequestOption) *discordgo.Channel); ok {
		r0 = rf(channelID, name, typ, archiveDuration, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Channel)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, discordgo.ChannelType, int, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, name, typ, archiveDuration, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ThreadStartComplex provides a mock function with given fields: channelID, data, options
func (_m *ISession) ThreadStartComplex(channelID string, data *discordgo.ThreadStart, options ...discordgo.RequestOption) (*discordgo.Channel, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ThreadStartComplex")
	}

	var r0 *discordgo.Channel
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *discordgo.ThreadStart, ...discordgo.RequestOption) (*discordgo.Channel, error)); ok {
		return rf(channelID, data, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *discordgo.ThreadStart, ...discordgo.RequestOption) *discordgo.Channel); ok {
		r0 = rf(channelID, data, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Channel)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *discordgo.ThreadStart, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, data, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ThreadsActive provides a mock function with given fields: channelID, options
func (_m *ISession) ThreadsActive(channelID string, options ...discordgo.RequestOption) (*discordgo.ThreadsList, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ThreadsActive")
	}

	var r0 *discordgo.ThreadsList
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) (*discordgo.ThreadsList, error)); ok {
		return rf(channelID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) *discordgo.ThreadsList); ok {
		r0 = rf(channelID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.ThreadsList)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ThreadsArchived provides a mock function with given fields: channelID, before, limit, options
func (_m *ISession) ThreadsArchived(channelID string, before *time.Time, limit int, options ...discordgo.RequestOption) (*discordgo.ThreadsList, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, before, limit)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ThreadsArchived")
	}

	var r0 *discordgo.ThreadsList
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *time.Time, int, ...discordgo.RequestOption) (*discordgo.ThreadsList, error)); ok {
		return rf(channelID, before, limit, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *time.Time, int, ...discordgo.RequestOption) *discordgo.ThreadsList); ok {
		r0 = rf(channelID, before, limit, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.ThreadsList)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *time.Time, int, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, before, limit, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ThreadsPrivateArchived provides a mock function with given fields: channelID, before, limit, options
func (_m *ISession) ThreadsPrivateArchived(channelID string, before *time.Time, limit int, options ...discordgo.RequestOption) (*discordgo.ThreadsList, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, before, limit)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ThreadsPrivateArchived")
	}

	var r0 *discordgo.ThreadsList
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *time.Time, int, ...discordgo.RequestOption) (*discordgo.ThreadsList, error)); ok {
		return rf(channelID, before, limit, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *time.Time, int, ...discordgo.RequestOption) *discordgo.ThreadsList); ok {
		r0 = rf(channelID, before, limit, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.ThreadsList)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *time.Time, int, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, before, limit, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ThreadsPrivateJoinedArchived provides a mock function with given fields: channelID, before, limit, options
func (_m *ISession) ThreadsPrivateJoinedArchived(channelID string, before *time.Time, limit int, options ...discordgo.RequestOption) (*discordgo.ThreadsList, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, before, limit)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ThreadsPrivateJoinedArchived")
	}

	var r0 *discordgo.ThreadsList
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *time.Time, int, ...discordgo.RequestOption) (*discordgo.ThreadsList, error)); ok {
		return rf(channelID, before, limit, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *time.Time, int, ...discordgo.RequestOption) *discordgo.ThreadsList); ok {
		r0 = rf(channelID, before, limit, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.ThreadsList)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *time.Time, int, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, before, limit, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateCustomStatus provides a mock function with given fields: state
func (_m *ISession) UpdateCustomStatus(state string) error {
	ret := _m.Called(state)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCustomStatus")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(state)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateGameStatus provides a mock function with given fields: idle, name
func (_m *ISession) UpdateGameStatus(idle int, name string) error {
	ret := _m.Called(idle, name)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGameStatus")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int, string) error); ok {
		r0 = rf(idle, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateListeningStatus provides a mock function with given fields: name
func (_m *ISession) UpdateListeningStatus(name string) error {
	ret := _m.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for UpdateListeningStatus")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateStatusComplex provides a mock function with given fields: usd
func (_m *ISession) UpdateStatusComplex(usd discordgo.UpdateStatusData) error {
	ret := _m.Called(usd)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStatusComplex")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(discordgo.UpdateStatusData) error); ok {
		r0 = rf(usd)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateStreamingStatus provides a mock function with given fields: idle, name, url
func (_m *ISession) UpdateStreamingStatus(idle int, name string, url string) error {
	ret := _m.Called(idle, name, url)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStreamingStatus")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int, string, string) error); ok {
		r0 = rf(idle, name, url)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateWatchStatus provides a mock function with given fields: idle, name
func (_m *ISession) UpdateWatchStatus(idle int, name string) error {
	ret := _m.Called(idle, name)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWatchStatus")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int, string) error); ok {
		r0 = rf(idle, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// User provides a mock function with given fields: userID, options
func (_m *ISession) User(userID string, options ...discordgo.RequestOption) (*discordgo.User, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, userID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for User")
	}

	var r0 *discordgo.User
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) (*discordgo.User, error)); ok {
		return rf(userID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) *discordgo.User); ok {
		r0 = rf(userID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.User)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(userID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UserApplicationRoleConnection provides a mock function with given fields: appID
func (_m *ISession) UserApplicationRoleConnection(appID string) (*discordgo.ApplicationRoleConnection, error) {
	ret := _m.Called(appID)

	if len(ret) == 0 {
		panic("no return value specified for UserApplicationRoleConnection")
	}

	var r0 *discordgo.ApplicationRoleConnection
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*discordgo.ApplicationRoleConnection, error)); ok {
		return rf(appID)
	}
	if rf, ok := ret.Get(0).(func(string) *discordgo.ApplicationRoleConnection); ok {
		r0 = rf(appID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.ApplicationRoleConnection)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(appID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UserApplicationRoleConnectionUpdate provides a mock function with given fields: appID, rconn
func (_m *ISession) UserApplicationRoleConnectionUpdate(appID string, rconn *discordgo.ApplicationRoleConnection) (*discordgo.ApplicationRoleConnection, error) {
	ret := _m.Called(appID, rconn)

	if len(ret) == 0 {
		panic("no return value specified for UserApplicationRoleConnectionUpdate")
	}

	var r0 *discordgo.ApplicationRoleConnection
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *discordgo.ApplicationRoleConnection) (*discordgo.ApplicationRoleConnection, error)); ok {
		return rf(appID, rconn)
	}
	if rf, ok := ret.Get(0).(func(string, *discordgo.ApplicationRoleConnection) *discordgo.ApplicationRoleConnection); ok {
		r0 = rf(appID, rconn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.ApplicationRoleConnection)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *discordgo.ApplicationRoleConnection) error); ok {
		r1 = rf(appID, rconn)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UserAvatar provides a mock function with given fields: userID, options
func (_m *ISession) UserAvatar(userID string, options ...discordgo.RequestOption) (image.Image, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, userID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UserAvatar")
	}

	var r0 image.Image
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) (image.Image, error)); ok {
		return rf(userID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) image.Image); ok {
		r0 = rf(userID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(image.Image)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(userID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UserAvatarDecode provides a mock function with given fields: u, options
func (_m *ISession) UserAvatarDecode(u *discordgo.User, options ...discordgo.RequestOption) (image.Image, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, u)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UserAvatarDecode")
	}

	var r0 image.Image
	var r1 error
	if rf, ok := ret.Get(0).(func(*discordgo.User, ...discordgo.RequestOption) (image.Image, error)); ok {
		return rf(u, options...)
	}
	if rf, ok := ret.Get(0).(func(*discordgo.User, ...discordgo.RequestOption) image.Image); ok {
		r0 = rf(u, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(image.Image)
		}
	}

	if rf, ok := ret.Get(1).(func(*discordgo.User, ...discordgo.RequestOption) error); ok {
		r1 = rf(u, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UserChannelCreate provides a mock function with given fields: recipientID, options
func (_m *ISession) UserChannelCreate(recipientID string, options ...discordgo.RequestOption) (*discordgo.Channel, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, recipientID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UserChannelCreate")
	}

	var r0 *discordgo.Channel
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) (*discordgo.Channel, error)); ok {
		return rf(recipientID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) *discordgo.Channel); ok {
		r0 = rf(recipientID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Channel)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(recipientID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UserChannelPermissions provides a mock function with given fields: userID, channelID, fetchOptions
func (_m *ISession) UserChannelPermissions(userID string, channelID string, fetchOptions ...discordgo.RequestOption) (int64, error) {
	_va := make([]interface{}, len(fetchOptions))
	for _i := range fetchOptions {
		_va[_i] = fetchOptions[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, userID, channelID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UserChannelPermissions")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) (int64, error)); ok {
		return rf(userID, channelID, fetchOptions...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) int64); ok {
		r0 = rf(userID, channelID, fetchOptions...)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(userID, channelID, fetchOptions...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UserConnections provides a mock function with given fields: options
func (_m *ISession) UserConnections(options ...discordgo.RequestOption) ([]*discordgo.UserConnection, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UserConnections")
	}

	var r0 []*discordgo.UserConnection
	var r1 error
	if rf, ok := ret.Get(0).(func(...discordgo.RequestOption) ([]*discordgo.UserConnection, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...discordgo.RequestOption) []*discordgo.UserConnection); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.UserConnection)
		}
	}

	if rf, ok := ret.Get(1).(func(...discordgo.RequestOption) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UserGuildMember provides a mock function with given fields: guildID, options
func (_m *ISession) UserGuildMember(guildID string, options ...discordgo.RequestOption) (*discordgo.Member, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, guildID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UserGuildMember")
	}

	var r0 *discordgo.Member
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) (*discordgo.Member, error)); ok {
		return rf(guildID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) *discordgo.Member); ok {
		r0 = rf(guildID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Member)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(guildID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UserGuilds provides a mock function with given fields: limit, beforeID, afterID, withCounts, options
func (_m *ISession) UserGuilds(limit int, beforeID string, afterID string, withCounts bool, options ...discordgo.RequestOption) ([]*discordgo.UserGuild, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, limit, beforeID, afterID, withCounts)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UserGuilds")
	}

	var r0 []*discordgo.UserGuild
	var r1 error
	if rf, ok := ret.Get(0).(func(int, string, string, bool, ...discordgo.RequestOption) ([]*discordgo.UserGuild, error)); ok {
		return rf(limit, beforeID, afterID, withCounts, options...)
	}
	if rf, ok := ret.Get(0).(func(int, string, string, bool, ...discordgo.RequestOption) []*discordgo.UserGuild); ok {
		r0 = rf(limit, beforeID, afterID, withCounts, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.UserGuild)
		}
	}

	if rf, ok := ret.Get(1).(func(int, string, string, bool, ...discordgo.RequestOption) error); ok {
		r1 = rf(limit, beforeID, afterID, withCounts, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UserUpdate provides a mock function with given fields: username, avatar, options
func (_m *ISession) UserUpdate(username string, avatar string, options ...discordgo.RequestOption) (*discordgo.User, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, username, avatar)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UserUpdate")
	}

	var r0 *discordgo.User
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) (*discordgo.User, error)); ok {
		return rf(username, avatar, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) *discordgo.User); ok {
		r0 = rf(username, avatar, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.User)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(username, avatar, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VoiceRegions provides a mock function with given fields: options
func (_m *ISession) VoiceRegions(options ...discordgo.RequestOption) ([]*discordgo.VoiceRegion, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VoiceRegions")
	}

	var r0 []*discordgo.VoiceRegion
	var r1 error
	if rf, ok := ret.Get(0).(func(...discordgo.RequestOption) ([]*discordgo.VoiceRegion, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...discordgo.RequestOption) []*discordgo.VoiceRegion); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*discordgo.VoiceRegion)
		}
	}

	if rf, ok := ret.Get(1).(func(...discordgo.RequestOption) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Webhook provides a mock function with given fields: webhookID, options
func (_m *ISession) Webhook(webhookID string, options ...discordgo.RequestOption) (*discordgo.Webhook, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, webhookID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Webhook")
	}

	var r0 *discordgo.Webhook
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) (*discordgo.Webhook, error)); ok {
		return rf(webhookID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) *discordgo.Webhook); ok {
		r0 = rf(webhookID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Webhook)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...discordgo.RequestOption) error); ok {
		r1 = rf(webhookID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WebhookCreate provides a mock function with given fields: channelID, name, avatar, options
func (_m *ISession) WebhookCreate(channelID string, name string, avatar string, options ...discordgo.RequestOption) (*discordgo.Webhook, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, channelID, name, avatar)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WebhookCreate")
	}

	var r0 *discordgo.Webhook
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, ...discordgo.RequestOption) (*discordgo.Webhook, error)); ok {
		return rf(channelID, name, avatar, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, ...discordgo.RequestOption) *discordgo.Webhook); ok {
		r0 = rf(channelID, name, avatar, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Webhook)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(channelID, name, avatar, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WebhookDelete provides a mock function with given fields: webhookID, options
func (_m *ISession) WebhookDelete(webhookID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, webhookID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WebhookDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...discordgo.RequestOption) error); ok {
		r0 = rf(webhookID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WebhookDeleteWithToken provides a mock function with given fields: webhookID, token, options
func (_m *ISession) WebhookDeleteWithToken(webhookID string, token string, options ...discordgo.RequestOption) (*discordgo.Webhook, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, webhookID, token)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WebhookDeleteWithToken")
	}

	var r0 *discordgo.Webhook
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) (*discordgo.Webhook, error)); ok {
		return rf(webhookID, token, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) *discordgo.Webhook); ok {
		r0 = rf(webhookID, token, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Webhook)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(webhookID, token, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WebhookEdit provides a mock function with given fields: webhookID, name, avatar, channelID, options
func (_m *ISession) WebhookEdit(webhookID string, name string, avatar string, channelID string, options ...discordgo.RequestOption) (*discordgo.Webhook, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, webhookID, name, avatar, channelID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WebhookEdit")
	}

	var r0 *discordgo.Webhook
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, string, ...discordgo.RequestOption) (*discordgo.Webhook, error)); ok {
		return rf(webhookID, name, avatar, channelID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, string, ...discordgo.RequestOption) *discordgo.Webhook); ok {
		r0 = rf(webhookID, name, avatar, channelID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Webhook)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(webhookID, name, avatar, channelID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WebhookEditWithToken provides a mock function with given fields: webhookID, token, name, avatar, options
func (_m *ISession) WebhookEditWithToken(webhookID string, token string, name string, avatar string, options ...discordgo.RequestOption) (*discordgo.Webhook, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, webhookID, token, name, avatar)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WebhookEditWithToken")
	}

	var r0 *discordgo.Webhook
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, string, ...discordgo.RequestOption) (*discordgo.Webhook, error)); ok {
		return rf(webhookID, token, name, avatar, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, string, ...discordgo.RequestOption) *discordgo.Webhook); ok {
		r0 = rf(webhookID, token, name, avatar, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Webhook)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(webhookID, token, name, avatar, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WebhookExecute provides a mock function with given fields: webhookID, token, wait, data, options
func (_m *ISession) WebhookExecute(webhookID string, token string, wait bool, data *discordgo.WebhookParams, options ...discordgo.RequestOption) (*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, webhookID, token, wait, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WebhookExecute")
	}

	var r0 *discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, bool, *discordgo.WebhookParams, ...discordgo.RequestOption) (*discordgo.Message, error)); ok {
		return rf(webhookID, token, wait, data, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, bool, *discordgo.WebhookParams, ...discordgo.RequestOption) *discordgo.Message); ok {
		r0 = rf(webhookID, token, wait, data, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, bool, *discordgo.WebhookParams, ...discordgo.RequestOption) error); ok {
		r1 = rf(webhookID, token, wait, data, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WebhookMessage provides a mock function with given fields: webhookID, token, messageID, options
func (_m *ISession) WebhookMessage(webhookID string, token string, messageID string, options ...discordgo.RequestOption) (*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, webhookID, token, messageID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WebhookMessage")
	}

	var r0 *discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, ...discordgo.RequestOption) (*discordgo.Message, error)); ok {
		return rf(webhookID, token, messageID, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, ...discordgo.RequestOption) *discordgo.Message); ok {
		r0 = rf(webhookID, token, messageID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(webhookID, token, messageID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WebhookMessageDelete provides a mock function with given fields: webhookID, token, messageID, options
func (_m *ISession) WebhookMessageDelete(webhookID string, token string, messageID string, options ...discordgo.RequestOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, webhookID, token, messageID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WebhookMessageDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, ...discordgo.RequestOption) error); ok {
		r0 = rf(webhookID, token, messageID, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WebhookMessageEdit provides a mock function with given fields: webhookID, token, messageID, data, options
func (_m *ISession) WebhookMessageEdit(webhookID string, token string, messageID string, data *discordgo.WebhookEdit, options ...discordgo.RequestOption) (*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, webhookID, token, messageID, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WebhookMessageEdit")
	}

	var r0 *discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, *discordgo.WebhookEdit, ...discordgo.RequestOption) (*discordgo.Message, error)); ok {
		return rf(webhookID, token, messageID, data, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, *discordgo.WebhookEdit, ...discordgo.RequestOption) *discordgo.Message); ok {
		r0 = rf(webhookID, token, messageID, data, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, *discordgo.WebhookEdit, ...discordgo.RequestOption) error); ok {
		r1 = rf(webhookID, token, messageID, data, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WebhookThreadExecute provides a mock function with given fields: webhookID, token, wait, threadID, data, options
func (_m *ISession) WebhookThreadExecute(webhookID string, token string, wait bool, threadID string, data *discordgo.WebhookParams, options ...discordgo.RequestOption) (*discordgo.Message, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, webhookID, token, wait, threadID, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WebhookThreadExecute")
	}

	var r0 *discordgo.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, bool, string, *discordgo.WebhookParams, ...discordgo.RequestOption) (*discordgo.Message, error)); ok {
		return rf(webhookID, token, wait, threadID, data, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, bool, string, *discordgo.WebhookParams, ...discordgo.RequestOption) *discordgo.Message); ok {
		r0 = rf(webhookID, token, wait, threadID, data, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, bool, string, *discordgo.WebhookParams, ...discordgo.RequestOption) error); ok {
		r1 = rf(webhookID, token, wait, threadID, data, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WebhookWithToken provides a mock function with given fields: webhookID, token, options
func (_m *ISession) WebhookWithToken(webhookID string, token string, options ...discordgo.RequestOption) (*discordgo.Webhook, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, webhookID, token)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WebhookWithToken")
	}

	var r0 *discordgo.Webhook
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) (*discordgo.Webhook, error)); ok {
		return rf(webhookID, token, options...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...discordgo.RequestOption) *discordgo.Webhook); ok {
		r0 = rf(webhookID, token, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.Webhook)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, ...discordgo.RequestOption) error); ok {
		r1 = rf(webhookID, token, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewISession creates a new instance of ISession. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewISession(t interface {
	mock.TestingT
	Cleanup(func())
}) *ISession {
	mock := &ISession{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
